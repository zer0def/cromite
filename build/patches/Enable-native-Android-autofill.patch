From: uazo <uazo@users.noreply.github.com>
Date: Sun, 24 Oct 2021 16:54:04 +0000
Subject: Enable native Android autofill

There are 2 different types of autofill: one managed via GCM and the
native Android one that uses the provider assigned by the user
(which can be any user installed app like Bitwarden for example).
In chromium GCM is active while in the WebView the latter.
This patch uses WebView code to enable native Android autofill
along with browser-managed autofill.
A separate toggle is introduced to enable autofill in incognito mode.

See also: https://github.com/bromite/bromite/issues/547

Original License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
License: GPL-3.0-only - https://spdx.org/licenses/GPL-3.0-only.html
---
 chrome/android/BUILD.gn                       |  1 +
 .../settings/PasswordSettings.java            | 81 ++++++++++++++++++-
 .../chrome/browser/settings/MainSettings.java |  3 +-
 .../chromium/chrome/browser/tab/TabImpl.java  | 45 ++++++++++-
 .../browser/tab/TabViewAndroidDelegate.java   |  4 +
 chrome/browser/BUILD.gn                       |  7 ++
 chrome/browser/about_flags.cc                 | 22 -----
 chrome/browser/android/tab_android.cc         |  8 ++
 .../options/AutofillOptionsCoordinator.java   |  2 -
 chrome/browser/flag_descriptions.cc           |  6 --
 chrome/browser/flag_descriptions.h            |  3 -
 .../flags/android/chrome_feature_list.cc      |  1 -
 .../strings/android_chrome_strings.grd        |  6 ++
 .../ui/autofill/autofill_client_provider.cc   |  8 +-
 components/android_autofill/browser/BUILD.gn  |  1 +
 .../browser/android_autofill_client.cc        | 10 +--
 .../browser/android_autofill_manager.cc       |  2 +
 .../browser/android_autofill_manager.h        |  2 +
 .../autofill_provider_android_bridge_impl.cc  |  1 -
 .../autofill/AndroidAutofillClient.java       |  1 +
 .../autofill/AutofillManagerWrapper.java      |  5 +-
 .../components/autofill/AutofillProvider.java |  7 ++
 .../BrowserSelectionActionMenuDelegate.java   | 62 ++++++++++++++
 .../browser/content_autofill_driver.cc        | 55 +++++++++++++
 .../content/browser/content_autofill_driver.h | 10 +++
 .../content_autofill_driver_factory.cc        | 12 +++
 .../content/renderer/autofill_agent.cc        |  6 ++
 .../renderer/password_autofill_agent.cc       |  5 +-
 .../autofill/core/browser/autofill_driver.h   |  2 +
 .../autofill/core/browser/autofill_manager.h  |  2 +
 .../core/browser/browser_autofill_manager.cc  |  2 +
 .../core/browser/browser_autofill_manager.h   |  2 +
 .../autofill/core/common/autofill_features.cc |  9 ---
 .../autofill/core/common/autofill_features.h  |  9 ---
 .../autofill/core/common/autofill_prefs.cc    |  2 +
 .../autofill/core/common/autofill_prefs.h     |  5 ++
 .../embedder_support/view/ContentView.java    | 47 +++++++++++
 .../chromium/ui/base/ViewAndroidDelegate.java |  4 +
 38 files changed, 384 insertions(+), 76 deletions(-)
 create mode 100644 components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java

diff --git a/chrome/android/BUILD.gn b/chrome/android/BUILD.gn
--- a/chrome/android/BUILD.gn
+++ b/chrome/android/BUILD.gn
@@ -463,6 +463,7 @@ if (current_toolchain == default_toolchain) {
       "//chrome/browser/ui/android/hats:message_ui_delegate_java",
       "//chrome/browser/ui/android/layouts:java",
       "//chrome/browser/ui/android/layouts/glue:java",
+      "//components/android_autofill/browser:java",
       "//chrome/browser/ui/android/logo:java",
       "//chrome/browser/ui/android/management:java",
       "//chrome/browser/ui/android/multiwindow:java",
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/password_manager/settings/PasswordSettings.java
@@ -59,6 +59,11 @@ import java.lang.annotation.Retention;
 import java.lang.annotation.RetentionPolicy;
 import java.util.Locale;
 
+import org.chromium.chrome.browser.ui.messages.snackbar.SnackbarManager;
+import org.chromium.chrome.browser.ui.messages.snackbar.INeedSnackbarManager;
+import org.chromium.chrome.browser.ui.messages.snackbar.Snackbar;
+import org.chromium.chrome.browser.ApplicationLifetime;
+
 /**
  * The "Passwords" screen in Settings, which allows the user to enable or disable password saving,
  * to view saved passwords (just the username and URL), and to delete saved passwords.
@@ -66,7 +71,7 @@ import java.util.Locale;
 public class PasswordSettings extends ChromeBaseSettingsFragment
         implements PasswordListObserver,
                 Preference.OnPreferenceClickListener,
-                SyncService.SyncStateChangedListener {
+                SyncService.SyncStateChangedListener, INeedSnackbarManager {
     @IntDef({
         TrustedVaultBannerState.NOT_SHOWN,
         TrustedVaultBannerState.OFFER_OPT_IN,
@@ -96,6 +101,12 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
     public static final String PREF_TRUSTED_VAULT_BANNER = "trusted_vault_banner";
     public static final String PREF_KEY_MANAGE_ACCOUNT_LINK = "manage_account_link";
 
+    public static final String PREF_ANDROID_AUTOFILL_SWITCH = "android_autofill_switch";
+    public static final String PREF_ANDROID_AUTOFILL_INCOGNITO_SWITCH = "android_autofill_incognito_switch";
+
+    private SnackbarManager mSnackbarManager;
+    private Snackbar mSnackbar;
+
     private static final String PREF_KEY_CATEGORY_SAVED_PASSWORDS = "saved_passwords";
     private static final String PREF_KEY_CATEGORY_EXCEPTIONS = "exceptions";
     private static final String PREF_KEY_SAVED_PASSWORDS_NO_TEXT = "saved_passwords_no_text";
@@ -128,6 +139,8 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
     private Preference mLinkPref;
     private Menu mMenu;
 
+    private ChromeSwitchPreference mEnableAndroidAutofillSwitch;
+    private ChromeSwitchPreference mEnableAndroidAutofillIncognitoSwitch;
     private @ManagePasswordsReferrer int mManagePasswordsReferrer;
     private BottomSheetController mBottomSheetController;
 
@@ -302,6 +315,7 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
         }
 
         createSavePasswordsSwitch();
+        createEnableAndroidAutofillSwitch();
         if (shouldShowAutoSigninOption()) {
             createAutoSignInCheckbox();
         }
@@ -577,6 +591,71 @@ public class PasswordSettings extends ChromeBaseSettingsFragment
                 getPrefService().getBoolean(Pref.CREDENTIALS_ENABLE_SERVICE));
     }
 
+    private void createEnableAndroidAutofillSwitch() {
+        if (mSnackbar == null) {
+            mSnackbar = Snackbar.make(getActivity().getString(R.string.ui_relaunch_notice),
+                    new SnackbarManager.SnackbarController() {
+                            @Override
+                            public void onDismissNoAction(Object actionData) { }
+
+                            @Override
+                            public void onAction(Object actionData) {
+                                ApplicationLifetime.terminate(true);
+                            }
+                    }, Snackbar.TYPE_NOTIFICATION, Snackbar.UMA_UNKNOWN)
+                    .setSingleLine(false)
+                    .setAction(getActivity().getString(R.string.relaunch),
+                            /*actionData*/null)
+                    .setDuration(/*durationMs*/70000);
+        }
+
+        mEnableAndroidAutofillSwitch = new ChromeSwitchPreference(getStyledContext(), null);
+        mEnableAndroidAutofillSwitch.setKey(PREF_ANDROID_AUTOFILL_SWITCH);
+        mEnableAndroidAutofillSwitch.setTitle(R.string.enable_android_autofill);
+        mEnableAndroidAutofillSwitch.setOrder(ORDER_SWITCH);
+        mEnableAndroidAutofillSwitch.setSummaryOn(R.string.text_on);
+        mEnableAndroidAutofillSwitch.setSummaryOff(R.string.text_off);
+
+        try (StrictModeContext ignored = StrictModeContext.allowDiskReads()) {
+            getPreferenceScreen().addPreference(mEnableAndroidAutofillSwitch);
+        }
+
+        mEnableAndroidAutofillSwitch.setChecked(
+                getPrefService().getBoolean(Pref.AUTOFILL_ANDROID_ENABLED));
+
+        mEnableAndroidAutofillSwitch.setOnPreferenceChangeListener((preference, newValue) -> {
+            getPrefService().setBoolean(Pref.AUTOFILL_ANDROID_ENABLED, (boolean) newValue);
+            if (!mSnackbarManager.isShowing())
+                mSnackbarManager.showSnackbar(mSnackbar);
+            return true;
+        });
+
+        mEnableAndroidAutofillIncognitoSwitch = new ChromeSwitchPreference(getStyledContext(), null);
+        mEnableAndroidAutofillIncognitoSwitch.setKey(PREF_ANDROID_AUTOFILL_INCOGNITO_SWITCH);
+        mEnableAndroidAutofillIncognitoSwitch.setTitle(R.string.enable_android_autofill_incognito);
+        mEnableAndroidAutofillIncognitoSwitch.setOrder(ORDER_SWITCH);
+        mEnableAndroidAutofillIncognitoSwitch.setSummaryOn(R.string.text_on);
+        mEnableAndroidAutofillIncognitoSwitch.setSummaryOff(R.string.text_off);
+
+        try (StrictModeContext ignored = StrictModeContext.allowDiskReads()) {
+            getPreferenceScreen().addPreference(mEnableAndroidAutofillIncognitoSwitch);
+        }
+
+        mEnableAndroidAutofillIncognitoSwitch.setChecked(
+                getPrefService().getBoolean(Pref.AUTOFILL_ANDROID_INCOGNITO_ENABLED));
+
+        mEnableAndroidAutofillIncognitoSwitch.setOnPreferenceChangeListener((preference, newValue) -> {
+            getPrefService().setBoolean(Pref.AUTOFILL_ANDROID_INCOGNITO_ENABLED, (boolean) newValue);
+            if (!mSnackbarManager.isShowing())
+                mSnackbarManager.showSnackbar(mSnackbar);
+            return true;
+        });
+    }
+
+    public void setSnackbarManager(SnackbarManager manager) {
+        mSnackbarManager = manager;
+    }
+
     private void createAutoSignInCheckbox() {
         ChromeSwitchPreference autoSignInSwitch =
                 new ChromeSwitchPreference(getStyledContext(), null);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java b/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/settings/MainSettings.java
@@ -396,8 +396,7 @@ public class MainSettings extends ChromeBaseSettingsFragment
 
     private void updateAutofillPreferences() {
         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O
-                && ChromeFeatureList.isEnabled(
-                        AutofillFeatures.AUTOFILL_VIRTUAL_VIEW_STRUCTURE_ANDROID)) {
+                && ((false))) {
             addPreferenceIfAbsent(PREF_AUTOFILL_OPTIONS);
             Preference preference = findPreference(PREF_AUTOFILL_OPTIONS);
             preference.setFragment(null);
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabImpl.java
@@ -81,6 +81,19 @@ import org.chromium.url.GURL;
 import java.nio.ByteBuffer;
 import java.util.Objects;
 
+import android.os.Build;
+import android.util.SparseArray;
+import org.chromium.ui.base.EventOffsetHandler;
+import android.view.ViewStructure;
+import android.view.autofill.AutofillValue;
+import org.chromium.components.autofill.AutofillProvider;
+import org.chromium.components.autofill.AutofillSelectionMenuItemHelper;
+import org.chromium.components.autofill.BrowserSelectionActionMenuDelegate;
+import org.chromium.content_public.browser.SelectionPopupController;
+import org.chromium.chrome.browser.preferences.Pref;
+import org.chromium.chrome.browser.profiles.ProfileManager;
+import org.chromium.components.user_prefs.UserPrefs;
+
 /**
  * Implementation of the interface {@link Tab}. Contains and manages a {@link ContentView}. This
  * class is not intended to be extended.
@@ -882,6 +895,11 @@ class TabImpl implements Tab {
         for (TabObserver observer : mObservers) observer.onDestroyed(this);
         mObservers.clear();
 
+        if (mAutofillProvider != null) {
+            mAutofillProvider.destroy();
+            mAutofillProvider = null;
+        }
+
         mUserDataHost.destroy();
         mTabViewManager.destroy();
         hideNativePage(false, null);
@@ -1154,8 +1172,7 @@ class TabImpl implements Tab {
      */
     boolean providesAutofillStructure() {
         // TODO(b/326231439): Check pref and AutofillService!
-        return ChromeFeatureList.isEnabled(
-                AutofillFeatures.AUTOFILL_VIRTUAL_VIEW_STRUCTURE_ANDROID);
+        return true;
     }
 
     // Forwarded from TabWebContentsDelegateAndroid.
@@ -1610,6 +1627,30 @@ class TabImpl implements Tab {
                     prepareAutofillProvider(webContents)
                             ? View.IMPORTANT_FOR_AUTOFILL_YES
                             : View.IMPORTANT_FOR_AUTOFILL_NO_EXCLUDE_DESCENDANTS);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                boolean autofillEnabled = false;
+                if (isIncognito()) {
+                    autofillEnabled = UserPrefs.get(ProfileManager.getLastUsedRegularProfile())
+                                               .getBoolean(Pref.AUTOFILL_ANDROID_INCOGNITO_ENABLED);
+                } else {
+                    autofillEnabled = UserPrefs.get(ProfileManager.getLastUsedRegularProfile())
+                                               .getBoolean(Pref.AUTOFILL_ANDROID_ENABLED);
+                }
+
+                if (autofillEnabled) {
+                    SelectionPopupController selectionController =
+                            SelectionPopupController.fromWebContents(mWebContents);
+                    mAutofillProvider = new AutofillProvider(getContext(), cv, webContents, "bromite");
+                    TabImplJni.get().initializeAutofillIfNecessary(mNativeTabAndroid);
+                    mAutofillProvider.setWebContents(webContents);
+                    cv.setWebContents(webContents);
+                    BrowserSelectionActionMenuDelegate selectionActionMenuDelegate =
+                            new BrowserSelectionActionMenuDelegate();
+                    selectionActionMenuDelegate.setAutofillSelectionMenuItemHelper(
+                            new AutofillSelectionMenuItemHelper(getContext(), mAutofillProvider));
+                    selectionController.setSelectionActionMenuDelegate(selectionActionMenuDelegate);
+                }
+            }
             TabHelpers.initWebContentsHelpers(this);
             notifyContentChanged();
         } finally {
diff --git a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabViewAndroidDelegate.java b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabViewAndroidDelegate.java
--- a/chrome/android/java/src/org/chromium/chrome/browser/tab/TabViewAndroidDelegate.java
+++ b/chrome/android/java/src/org/chromium/chrome/browser/tab/TabViewAndroidDelegate.java
@@ -23,6 +23,10 @@ import org.chromium.ui.base.WindowAndroid;
 import org.chromium.ui.dragdrop.DragAndDropBrowserDelegate;
 import org.chromium.ui.dragdrop.DragStateTracker;
 
+import android.util.SparseArray;
+import android.view.autofill.AutofillValue;
+import android.view.ViewStructure;
+
 /** Implementation of the abstract class {@link ViewAndroidDelegate} for Chrome. */
 public class TabViewAndroidDelegate extends ViewAndroidDelegate {
     private final TabImpl mTab;
diff --git a/chrome/browser/BUILD.gn b/chrome/browser/BUILD.gn
--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -2671,6 +2671,13 @@ static_library("browser") {
     deps += [ "//chrome/browser/error_reporting" ]
   }
 
+  if (is_android) {
+    deps += [
+        "//components/android_autofill/browser",
+        "//components/android_autofill/browser:android"
+    ]
+  }
+
   if (use_ozone) {
     deps += [
       "//ui/events/ozone",
diff --git a/chrome/browser/about_flags.cc b/chrome/browser/about_flags.cc
--- a/chrome/browser/about_flags.cc
+++ b/chrome/browser/about_flags.cc
@@ -3763,19 +3763,6 @@ const FeatureEntry::FeatureVariation kLinkPreviewTriggerTypeVariations[] = {
      std::size(kLinkPreviewTriggerTypeLongPress), nullptr}};
 #endif  // !BUILDFLAG(IS_ANDROID)
 
-#if BUILDFLAG(IS_ANDROID)
-inline constexpr flags_ui::FeatureEntry::FeatureParam
-    kAutofillVirtualViewStructureAndroidSkipsCompatibilityCheckParam = {
-        autofill::features::
-            kAutofillVirtualViewStructureAndroidSkipsCompatibilityCheck.name,
-        "true"};
-inline constexpr flags_ui::FeatureEntry::FeatureVariation
-    kAutofillVirtualViewStructureVariation[] = {
-        {"Enabled without compatibility check",
-         &kAutofillVirtualViewStructureAndroidSkipsCompatibilityCheckParam, 1,
-         nullptr}};
-#endif  // BUILDFLAG(IS_ANDROID)
-
 const FeatureEntry::FeatureParam kDefaultBrowserPromptRefreshAggressive[] = {
     {"max_prompt_count", "-1"},
     {"reprompt_duration", "7d"},
@@ -5736,15 +5723,6 @@ const FeatureEntry kFeatureEntries[] = {
 #endif  // BUILDFLAG(IS_CHROMEOS_ASH)
 
 #if BUILDFLAG(IS_ANDROID)
-    {"enable-autofill-virtual-view-structure",
-     flag_descriptions::kAutofillVirtualViewStructureAndroidName,
-     flag_descriptions::kAutofillVirtualViewStructureAndroidDescription,
-     kOsAndroid,
-     FEATURE_WITH_PARAMS_VALUE_TYPE(
-         autofill::features::kAutofillVirtualViewStructureAndroid,
-         kAutofillVirtualViewStructureVariation,
-         "Skip AutofillService Check")},
-
     {"enable-pix-detection", flag_descriptions::kEnablePixDetectionName,
      flag_descriptions::kEnablePixDetectionDescription, kOsAndroid,
      FEATURE_VALUE_TYPE(payments::facilitated::kEnablePixDetection)},
diff --git a/chrome/browser/android/tab_android.cc b/chrome/browser/android/tab_android.cc
--- a/chrome/browser/android/tab_android.cc
+++ b/chrome/browser/android/tab_android.cc
@@ -60,6 +60,13 @@
 #include "url/android/gurl_android.h"
 #include "url/gurl.h"
 
+#include "components/android_autofill/browser/android_autofill_manager.h"
+#include "components/android_autofill/browser/autofill_provider.h"
+#include "components/android_autofill/browser/autofill_provider_android.h"
+#include "components/autofill/content/browser/content_autofill_driver_factory.h"
+#include "chrome/browser/ui/autofill/chrome_autofill_client.h"
+#include "chrome/browser/browser_process.h"
+
 using base::android::AttachCurrentThread;
 using base::android::ConvertUTF8ToJavaString;
 using base::android::JavaParamRef;
@@ -364,6 +371,7 @@ void TabAndroid::InitializeAutofillIfNecessary(JNIEnv* env) {
   if (autofill::AutofillProvider::FromWebContents(web_contents_.get())) {
     return;
   }
+  autofill::ChromeAutofillClient::CreateForWebContents(web_contents_.get());
   android_autofill::AndroidAutofillClient::CreateForWebContents(
       web_contents_.get(), [&](const JavaRef<jobject>& client) {});
 
diff --git a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/options/AutofillOptionsCoordinator.java b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/options/AutofillOptionsCoordinator.java
--- a/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/options/AutofillOptionsCoordinator.java
+++ b/chrome/browser/autofill/android/java/src/org/chromium/chrome/browser/autofill/options/AutofillOptionsCoordinator.java
@@ -55,8 +55,6 @@ public class AutofillOptionsCoordinator {
 
     @VisibleForTesting
     AutofillOptionsCoordinator(AutofillOptionsFragment fragment) {
-        assert ChromeFeatureList.isEnabled(
-                AutofillFeatures.AUTOFILL_VIRTUAL_VIEW_STRUCTURE_ANDROID);
         mFragment = fragment;
         mMediator = new AutofillOptionsMediator(mFragment.getProfile());
     }
diff --git a/chrome/browser/flag_descriptions.cc b/chrome/browser/flag_descriptions.cc
--- a/chrome/browser/flag_descriptions.cc
+++ b/chrome/browser/flag_descriptions.cc
@@ -680,12 +680,6 @@ const char kAutofillUpdateChromeSettingsLinkToGPayWebDescription[] =
     "When enabled, Chrome Settings link directs to GPay Web rather than "
     "Payments Center for payment methods management.";
 
-const char kAutofillVirtualViewStructureAndroidName[] =
-    "Enable the setting to provide a virtual view structure for Autofill";
-const char kAutofillVirtualViewStructureAndroidDescription[] =
-    "When enabled, a setting allows to switch to using Android Autofill. Chrome"
-    " then provides a virtual view structure but no own suggestions.";
-
 const char kBackForwardCacheName[] = "Back-forward cache";
 const char kBackForwardCacheDescription[] =
     "If enabled, caches eligible pages after cross-site navigations."
diff --git a/chrome/browser/flag_descriptions.h b/chrome/browser/flag_descriptions.h
--- a/chrome/browser/flag_descriptions.h
+++ b/chrome/browser/flag_descriptions.h
@@ -390,9 +390,6 @@ extern const char kAutofillUpdateChromeSettingsLinkToGPayWebDescription[];
 extern const char kAutofillMoreProminentPopupName[];
 extern const char kAutofillMoreProminentPopupDescription[];
 
-extern const char kAutofillVirtualViewStructureAndroidName[];
-extern const char kAutofillVirtualViewStructureAndroidDescription[];
-
 extern const char kBackForwardCacheName[];
 extern const char kBackForwardCacheDescription[];
 
diff --git a/chrome/browser/flags/android/chrome_feature_list.cc b/chrome/browser/flags/android/chrome_feature_list.cc
--- a/chrome/browser/flags/android/chrome_feature_list.cc
+++ b/chrome/browser/flags/android/chrome_feature_list.cc
@@ -87,7 +87,6 @@ const base::Feature* const kFeaturesExposedToJava[] = {
     &autofill::features::kAutofillEnableCardArtImage,
     &autofill::features::kAutofillEnableCardProductName,
     &autofill::features::kAutofillEnableLocalIban,
-    &autofill::features::kAutofillVirtualViewStructureAndroid,
     &autofill::features::kAutofillEnablePaymentsMandatoryReauth,
     &autofill::features::kAutofillEnableMovingGPayLogoToTheRightOnClank,
     &autofill::features::kAutofillEnableCvcStorageAndFilling,
diff --git a/chrome/browser/ui/android/strings/android_chrome_strings.grd b/chrome/browser/ui/android/strings/android_chrome_strings.grd
--- a/chrome/browser/ui/android/strings/android_chrome_strings.grd
+++ b/chrome/browser/ui/android/strings/android_chrome_strings.grd
@@ -666,6 +666,12 @@ CHAR_LIMIT guidelines:
       <message name="IDS_PASSWORD_SETTINGS_SAVE_PASSWORDS" desc="Title for the checkbox toggling whether passwords are saved or not. [CHAR_LIMIT=32]">
         Save passwords
       </message>
+      <message name="IDS_ENABLE_ANDROID_AUTOFILL" desc="Title for the checkbox toggling whether enable Android native autofill or not. [CHAR_LIMIT=32]">
+        Enable native Android autofill
+      </message>
+      <message name="IDS_ENABLE_ANDROID_AUTOFILL_INCOGNITO" desc="Title for the checkbox toggling whether enable Android native autofill or not in incognito mode. [CHAR_LIMIT=32]">
+        Enable native Android autofill in incognito
+      </message>
       <message name="IDS_PASSWORDS_AUTO_SIGNIN_TITLE" desc="Title for checkbox to enable automatically signing the user in to websites">
         Auto Sign-in
       </message>
diff --git a/chrome/browser/ui/autofill/autofill_client_provider.cc b/chrome/browser/ui/autofill/autofill_client_provider.cc
--- a/chrome/browser/ui/autofill/autofill_client_provider.cc
+++ b/chrome/browser/ui/autofill/autofill_client_provider.cc
@@ -21,13 +21,7 @@ namespace {
 
 bool UsesVirtualViewStructureForAutofill(const PrefService* prefs) {
 #if BUILDFLAG(IS_ANDROID)
-  if (!base::FeatureList::IsEnabled(
-          features::kAutofillVirtualViewStructureAndroid)) {
-    return false;
-  }
-
-  return prefs->GetBoolean(prefs::kAutofillUsingVirtualViewStructure) &&
-         android_autofill::AndroidAutofillClient::AllowedForAutofillService();
+  return true;
 #else
   return false;
 #endif  // BUILDFLAG(IS_ANDROID)
diff --git a/components/android_autofill/browser/BUILD.gn b/components/android_autofill/browser/BUILD.gn
--- a/components/android_autofill/browser/BUILD.gn
+++ b/components/android_autofill/browser/BUILD.gn
@@ -41,6 +41,7 @@ android_library("java") {
     "java/src/org/chromium/components/autofill/AutofillProviderUMA.java",
     "java/src/org/chromium/components/autofill/AutofillRequest.java",
     "java/src/org/chromium/components/autofill/AutofillSelectionMenuItemHelper.java",
+    "java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java",
     "java/src/org/chromium/components/autofill/FormData.java",
     "java/src/org/chromium/components/autofill/FormFieldData.java",
     "java/src/org/chromium/components/autofill/PrefillRequest.java",
diff --git a/components/android_autofill/browser/android_autofill_client.cc b/components/android_autofill/browser/android_autofill_client.cc
--- a/components/android_autofill/browser/android_autofill_client.cc
+++ b/components/android_autofill/browser/android_autofill_client.cc
@@ -37,9 +37,6 @@
 #include "ui/android/view_android.h"
 #include "ui/gfx/geometry/rect_f.h"
 
-using autofill::features::kAutofillVirtualViewStructureAndroid;
-using autofill::features::
-    kAutofillVirtualViewStructureAndroidSkipsCompatibilityCheck;
 using base::android::AttachCurrentThread;
 using base::android::ConvertUTF16ToJavaString;
 using base::android::JavaParamRef;
@@ -62,12 +59,7 @@ void AndroidAutofillClient::CreateForWebContents(
 
 // static
 bool AndroidAutofillClient::AllowedForAutofillService() {
-  if (!base::FeatureList::IsEnabled(kAutofillVirtualViewStructureAndroid)) {
-    return false;
-  }
-  if (kAutofillVirtualViewStructureAndroidSkipsCompatibilityCheck.Get()) {
-    return true;
-  }
+  if ((true)) return true;
   return Java_AndroidAutofillClient_allowedForAutofillService(
       AttachCurrentThread());
 }
diff --git a/components/android_autofill/browser/android_autofill_manager.cc b/components/android_autofill/browser/android_autofill_manager.cc
--- a/components/android_autofill/browser/android_autofill_manager.cc
+++ b/components/android_autofill/browser/android_autofill_manager.cc
@@ -33,6 +33,8 @@ AndroidAutofillManager::~AndroidAutofillManager() {
   Reset();
 }
 
+bool AndroidAutofillManager::IsAndroidAutofill() const { return true; }
+
 base::WeakPtr<AutofillManager> AndroidAutofillManager::GetWeakPtr() {
   return weak_ptr_factory_.GetWeakPtr();
 }
diff --git a/components/android_autofill/browser/android_autofill_manager.h b/components/android_autofill/browser/android_autofill_manager.h
--- a/components/android_autofill/browser/android_autofill_manager.h
+++ b/components/android_autofill/browser/android_autofill_manager.h
@@ -33,6 +33,8 @@ class AndroidAutofillManager : public AutofillManager,
 
   ~AndroidAutofillManager() override;
 
+  bool IsAndroidAutofill() const override;
+
   base::WeakPtr<AndroidAutofillManager> GetWeakPtrToLeafClass() {
     return weak_ptr_factory_.GetWeakPtr();
   }
diff --git a/components/android_autofill/browser/autofill_provider_android_bridge_impl.cc b/components/android_autofill/browser/autofill_provider_android_bridge_impl.cc
--- a/components/android_autofill/browser/autofill_provider_android_bridge_impl.cc
+++ b/components/android_autofill/browser/autofill_provider_android_bridge_impl.cc
@@ -52,7 +52,6 @@ AutofillProviderAndroidBridgeImpl::~AutofillProviderAndroidBridgeImpl() {
 void AutofillProviderAndroidBridgeImpl::AttachToJavaAutofillProvider(
     JNIEnv* env,
     const JavaRef<jobject>& jcaller) {
-  DCHECK(java_ref_.get(env).is_null());
   java_ref_ = JavaObjectWeakGlobalRef(env, jcaller);
 
   ScopedJavaLocalRef<jobject> obj = java_ref_.get(env);
diff --git a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AndroidAutofillClient.java b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AndroidAutofillClient.java
--- a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AndroidAutofillClient.java
+++ b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AndroidAutofillClient.java
@@ -37,6 +37,7 @@ public class AndroidAutofillClient {
 
     @CalledByNative
     public static boolean allowedForAutofillService() {
+        if ((true)) return true;
         if (Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
             return false;
         }
diff --git a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java
--- a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java
+++ b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillManagerWrapper.java
@@ -51,6 +51,7 @@ public class AutofillManagerWrapper {
             AutofillManagerWrapper manager = mManager.get();
             if (manager == null) return;
             manager.mIsAutofillInputUIShowing = (event == EVENT_INPUT_SHOWN);
+            if (manager.isLoggable()) manager.log("onAutofillEvent isAutofillInputUIShowing: " + manager.mIsAutofillInputUIShowing);
             if (event == EVENT_INPUT_SHOWN) manager.notifyInputUIChange();
         }
     }
@@ -91,6 +92,7 @@ public class AutofillManagerWrapper {
                 // Uses Exception to catch various cases. (refer to crbug.com/1186406)
                 Log.e(TAG, "getAutofillServiceComponentName", e);
             }
+            if (isLoggable()) log("componentName=" + componentName);
             if (componentName != null) {
                 mPackageName = componentName.getPackageName();
                 mIsAwGCurrentAutofillService =
@@ -256,7 +258,7 @@ public class AutofillManagerWrapper {
     /** Always check isLoggable() before call this method. */
     public static void log(String log) {
         // Log.i() instead of Log.d() is used here because log.d() is stripped out in release build.
-        Log.i(TAG, log);
+        Log.i(TAG, "---" + log);
     }
 
     public static boolean isLoggable() {
@@ -269,6 +271,7 @@ public class AutofillManagerWrapper {
         // NOTE: See the comment on TAG above for why this is still AwAutofillManager.
         // Check the system setting directly.
         sIsLoggable = android.util.Log.isLoggable(TAG, Log.DEBUG);
+        // sIsLoggable = true; // to force enable the log
     }
 
 }
diff --git a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java
--- a/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java
+++ b/components/android_autofill/browser/java/src/org/chromium/components/autofill/AutofillProvider.java
@@ -192,13 +192,19 @@ public class AutofillProvider {
 
     /** @return whether query autofill suggestion. */
     public boolean shouldQueryAutofillSuggestion() {
+        AutofillManagerWrapper.log("---shouldQueryAutofillSuggestion" +
+            "  mRequest != null=" + (mRequest != null) +
+            "  mRequest.getFocusField() != null=" + (mRequest != null && mRequest.getFocusField() != null) +
+            "  !mAutofillManager.isAutofillInputUIShowing()=" + ( !mAutofillManager.isAutofillInputUIShowing()));
         return mRequest != null
                 && mRequest.getFocusField() != null
                 && !mAutofillManager.isAutofillInputUIShowing();
     }
 
     public void queryAutofillSuggestion() {
+        AutofillManagerWrapper.log("queryAutofillSuggestion start");
         if (shouldQueryAutofillSuggestion()) {
+            AutofillManagerWrapper.log("calling requestAutofill");
             FocusField focusField = mRequest.getFocusField();
             mAutofillManager.requestAutofill(
                     mContainerView,
@@ -258,6 +264,7 @@ public class AutofillProvider {
             float width,
             float height,
             boolean hasServerPrediction) {
+        AutofillManagerWrapper.log("startAutofillSession");
         // Check focusField inside short value? Autofill Manager might have session that wasn't
         // started by AutofillProvider, we just always cancel existing session here.
         if (Build.VERSION.SDK_INT < Build.VERSION_CODES.P) {
diff --git a/components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java b/components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java
new file mode 100644
--- /dev/null
+++ b/components/android_autofill/browser/java/src/org/chromium/components/autofill/BrowserSelectionActionMenuDelegate.java
@@ -0,0 +1,62 @@
+// Copyright 2023 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+package org.chromium.components.autofill;
+
+import android.content.pm.ResolveInfo;
+
+import androidx.annotation.IntDef;
+import androidx.annotation.NonNull;
+
+import org.chromium.base.metrics.RecordHistogram;
+import org.chromium.components.autofill.AutofillSelectionMenuItemHelper;
+import org.chromium.content_public.browser.SelectionMenuItem;
+import org.chromium.content_public.browser.SelectionPopupController;
+import org.chromium.content_public.browser.selection.SelectionActionMenuDelegate;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.chromium.base.Log;
+
+/** Interface for customizing text selection menu items in {@link SelectionPopupController} */
+public class BrowserSelectionActionMenuDelegate implements SelectionActionMenuDelegate {
+    private AutofillSelectionMenuItemHelper mAutofillSelectionMenuItemHelper;
+
+    public BrowserSelectionActionMenuDelegate() {
+    }
+
+    @Override
+    public void modifyDefaultMenuItems(
+            List<SelectionMenuItem.Builder> menuItemBuilders,
+            boolean isSelectionPassword,
+            @NonNull String selectedText) {
+    }
+
+    @Override
+    public List<ResolveInfo> filterTextProcessingActivities(List<ResolveInfo> activities) {
+        return activities;
+    }
+
+    @NonNull
+    @Override
+    public List<SelectionMenuItem> getAdditionalNonSelectionItems() {
+        if (mAutofillSelectionMenuItemHelper != null) {
+            return mAutofillSelectionMenuItemHelper.getAdditionalItems();
+        }
+        return new ArrayList<>();
+    }
+
+    @NonNull
+    @Override
+    public List<SelectionMenuItem> getAdditionalTextProcessingItems() {
+        return new ArrayList<>();
+    }
+
+    public void setAutofillSelectionMenuItemHelper(AutofillSelectionMenuItemHelper provider) {
+        mAutofillSelectionMenuItemHelper = provider;
+    }
+}
diff --git a/components/autofill/content/browser/content_autofill_driver.cc b/components/autofill/content/browser/content_autofill_driver.cc
--- a/components/autofill/content/browser/content_autofill_driver.cc
+++ b/components/autofill/content/browser/content_autofill_driver.cc
@@ -427,6 +427,10 @@ void ContentAutofillDriver::FormsSeen(
                         const std::vector<FormGlobalId>& removed_forms) {
                        target->GetAutofillManager().OnFormsSeen(
                            WithNewVersion(updated_forms), removed_forms);
+                       if (target->secondary_autofill_manager()) {
+                         target->secondary_autofill_manager()->OnFormsSeen(
+                           WithNewVersion(updated_forms), removed_forms);
+                       }
                      });
 }
 
@@ -444,6 +448,10 @@ void ContentAutofillDriver::FormSubmitted(
          bool known_success, mojom::SubmissionSource submission_source) {
         target->GetAutofillManager().OnFormSubmitted(
             WithNewVersion(form), known_success, submission_source);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnFormSubmitted(
+            WithNewVersion(form), known_success, submission_source);
+        }
       });
 }
 
@@ -465,6 +473,10 @@ void ContentAutofillDriver::TextFieldDidChange(const FormData& raw_form,
          base::TimeTicks timestamp) {
         target->GetAutofillManager().OnTextFieldDidChange(
             WithNewVersion(form), field, bounding_box, timestamp);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnTextFieldDidChange(
+            WithNewVersion(form), field, bounding_box, timestamp);
+        }
       });
 }
 
@@ -484,6 +496,10 @@ void ContentAutofillDriver::TextFieldDidScroll(const FormData& raw_form,
          const FormFieldData& field, const gfx::RectF& bounding_box) {
         target->GetAutofillManager().OnTextFieldDidScroll(WithNewVersion(form),
                                                           field, bounding_box);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnTextFieldDidScroll(
+              WithNewVersion(form), field, bounding_box);
+        }
       });
 }
 
@@ -504,6 +520,10 @@ void ContentAutofillDriver::SelectControlDidChange(
          const FormFieldData& field, const gfx::RectF& bounding_box) {
         target->GetAutofillManager().OnSelectControlDidChange(
             WithNewVersion(form), field, bounding_box);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnSelectControlDidChange(
+            WithNewVersion(form), field, bounding_box);
+        }
       });
 }
 
@@ -526,6 +546,10 @@ void ContentAutofillDriver::AskForValuesToFill(
          AutofillSuggestionTriggerSource trigger_source) {
         target->GetAutofillManager().OnAskForValuesToFill(
             WithNewVersion(form), field, bounding_box, trigger_source);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnAskForValuesToFill(
+              WithNewVersion(form), field, bounding_box, trigger_source);
+        }
       });
 }
 
@@ -537,6 +561,8 @@ void ContentAutofillDriver::HidePopup() {
     DCHECK(!target->IsPrerendering())
         << "We should never affect UI while prerendering";
     target->GetAutofillManager().OnHidePopup();
+    if (target->secondary_autofill_manager())
+      target->secondary_autofill_manager()->OnHidePopup();
   });
 }
 
@@ -548,6 +574,8 @@ void ContentAutofillDriver::FocusNoLongerOnForm(bool had_interacted_form) {
       this, had_interacted_form,
       [](autofill::AutofillDriver* target, bool had_interacted_form) {
         target->GetAutofillManager().OnFocusNoLongerOnForm(had_interacted_form);
+        if (target->secondary_autofill_manager())
+          target->secondary_autofill_manager()->OnFocusNoLongerOnForm(had_interacted_form);
       });
 }
 
@@ -567,9 +595,16 @@ void ContentAutofillDriver::FocusOnFormField(const FormData& raw_form,
          const FormFieldData& field, const gfx::RectF& bounding_box) {
         target->GetAutofillManager().OnFocusOnFormField(WithNewVersion(form),
                                                         field, bounding_box);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnFocusOnFormField(
+            WithNewVersion(form), field, bounding_box);
+        }
       },
       [](autofill::AutofillDriver* target) {
         target->GetAutofillManager().OnFocusNoLongerOnForm(true);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnFocusNoLongerOnForm(true);
+        }
       });
 }
 
@@ -584,6 +619,10 @@ void ContentAutofillDriver::DidFillAutofillFormData(const FormData& raw_form,
          base::TimeTicks timestamp) {
         target->GetAutofillManager().OnDidFillAutofillFormData(
             WithNewVersion(form), timestamp);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnDidFillAutofillFormData(
+            WithNewVersion(form), timestamp);
+        }
       });
 }
 
@@ -593,6 +632,8 @@ void ContentAutofillDriver::DidEndTextFieldEditing() {
   }
   router().DidEndTextFieldEditing(this, [](autofill::AutofillDriver* target) {
     target->GetAutofillManager().OnDidEndTextFieldEditing();
+    if (target->secondary_autofill_manager())
+      target->secondary_autofill_manager()->OnDidEndTextFieldEditing();
   });
 }
 
@@ -607,6 +648,10 @@ void ContentAutofillDriver::SelectOrSelectListFieldOptionsDidChange(
         cast(target)
             ->GetAutofillManager()
             .OnSelectOrSelectListFieldOptionsDidChange(WithNewVersion(form));
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnSelectOrSelectListFieldOptionsDidChange(
+            WithNewVersion(form));
+        }
       });
 }
 
@@ -626,6 +671,10 @@ void ContentAutofillDriver::JavaScriptChangedAutofilledValue(
          const FormFieldData& field, const std::u16string& old_value) {
         target->GetAutofillManager().OnJavaScriptChangedAutofilledValue(
             WithNewVersion(form), field, old_value);
+        if (target->secondary_autofill_manager()) {
+          target->secondary_autofill_manager()->OnJavaScriptChangedAutofilledValue(
+            WithNewVersion(form), field, old_value);
+        }
       });
 }
 
@@ -633,6 +682,8 @@ void ContentAutofillDriver::Reset() {
   owner_->router().UnregisterDriver(this,
                                     /*driver_is_dying=*/false);
   autofill_manager_->Reset();
+  if (secondary_autofill_manager_)
+    secondary_autofill_manager_->Reset();
 }
 
 const mojo::AssociatedRemote<mojom::AutofillAgent>&
@@ -645,6 +696,10 @@ ContentAutofillDriver::GetAutofillAgent() {
   return autofill_agent_;
 }
 
+raw_ptr<AutofillManager> ContentAutofillDriver::secondary_autofill_manager() {
+  return secondary_autofill_manager_.get();
+}
+
 void ContentAutofillDriver::SetFrameAndFormMetaData(
     FormData& form,
     base::optional_ref<FormFieldData> field) const {
diff --git a/components/autofill/content/browser/content_autofill_driver.h b/components/autofill/content/browser/content_autofill_driver.h
--- a/components/autofill/content/browser/content_autofill_driver.h
+++ b/components/autofill/content/browser/content_autofill_driver.h
@@ -128,6 +128,12 @@ class ContentAutofillDriver : public AutofillDriver,
   ContentAutofillDriver& operator=(const ContentAutofillDriver&) = delete;
   ~ContentAutofillDriver() override;
 
+  void set_secondary_autofill_manager(
+      std::unique_ptr<AutofillManager> secondary_autofill_manager) {
+    secondary_autofill_manager_ = std::move(secondary_autofill_manager);
+  }
+  raw_ptr<AutofillManager> secondary_autofill_manager() override;
+
   content::RenderFrameHost* render_frame_host() { return &*render_frame_host_; }
   const content::RenderFrameHost* render_frame_host() const {
     return &*render_frame_host_;
@@ -310,6 +316,10 @@ class ContentAutofillDriver : public AutofillDriver,
   // The factory that created this driver. Outlives `this`.
   const raw_ref<ContentAutofillDriverFactory> owner_;
 
+  // adds a reference for AndroidAutofillManager, since native autofill works in
+  // conjunction with browser autofill in Bromite
+  std::unique_ptr<AutofillManager> secondary_autofill_manager_ = nullptr;
+
   mojo::AssociatedReceiver<mojom::AutofillDriver> receiver_{this};
 
   mojo::AssociatedRemote<mojom::AutofillAgent> autofill_agent_;
diff --git a/components/autofill/content/browser/content_autofill_driver_factory.cc b/components/autofill/content/browser/content_autofill_driver_factory.cc
--- a/components/autofill/content/browser/content_autofill_driver_factory.cc
+++ b/components/autofill/content/browser/content_autofill_driver_factory.cc
@@ -21,6 +21,12 @@
 #include "content/public/browser/web_contents.h"
 #include "third_party/blink/public/common/features.h"
 
+#if BUILDFLAG(IS_ANDROID)
+#include "components/android_autofill/browser/android_autofill_manager.h"
+#include "components/android_autofill/browser/autofill_provider.h"
+#include "components/android_autofill/browser/autofill_provider_android.h"
+#endif
+
 namespace autofill {
 
 class ScopedAutofillManagersObservation;
@@ -95,6 +101,12 @@ ContentAutofillDriver* ContentAutofillDriverFactory::DriverForFrame(
     // 5. `render_frame_host->~RenderFrameHostImpl()` finishes.
     if (render_frame_host->IsRenderFrameLive()) {
       driver = std::make_unique<ContentAutofillDriver>(render_frame_host, this);
+#if BUILDFLAG(IS_ANDROID)
+      if (!driver->GetAutofillManager().IsAndroidAutofill()) {
+        driver->set_secondary_autofill_manager(
+            base::WrapUnique(new AndroidAutofillManager(driver.get())));
+      }
+#endif
       for (Observer& observer : observers_) {
         observer.OnContentAutofillDriverCreated(*this, *driver);
       }
diff --git a/components/autofill/content/renderer/autofill_agent.cc b/components/autofill/content/renderer/autofill_agent.cc
--- a/components/autofill/content/renderer/autofill_agent.cc
+++ b/components/autofill/content/renderer/autofill_agent.cc
@@ -1009,12 +1009,16 @@ void AutofillAgent::ShowSuggestions(
         password_generation_agent_->ShowPasswordGenerationSuggestions(
             input_element)) {
       is_popup_possibly_visible_ = true;
+#if !BUILDFLAG(IS_ANDROID)
       return;
+#endif
     }
     if (password_autofill_agent_->ShowSuggestions(input_element,
                                                   trigger_source)) {
       is_popup_possibly_visible_ = true;
+#if !BUILDFLAG(IS_ANDROID)
       return;
+#endif
     }
   }
 
@@ -1026,12 +1030,14 @@ void AutofillAgent::ShowSuggestions(
   // parenthesis to not match a regex). In this specific case we are actually
   // interested in whether the field is currently a password field, not whether
   // it has ever been a password field.
+#if !BUILDFLAG(IS_ANDROID)
   if (!input_element.IsNull() &&
       input_element.IsPasswordField /*disable presubmit*/ () &&
       !config_.query_password_suggestions &&
       !is_address_or_payments_manual_fallback) {
     return;
   }
+#endif
 
   QueryAutofillSuggestions(element, trigger_source);
 }
diff --git a/components/autofill/content/renderer/password_autofill_agent.cc b/components/autofill/content/renderer/password_autofill_agent.cc
--- a/components/autofill/content/renderer/password_autofill_agent.cc
+++ b/components/autofill/content/renderer/password_autofill_agent.cc
@@ -827,7 +827,10 @@ void PasswordAutofillAgent::UpdatePasswordStateForTextChange(
 
 void PasswordAutofillAgent::TrackAutofilledElement(
     const blink::WebFormControlElement& element) {
-  autofill_agent_->TrackAutofilledElement(element);
+  // fix for https://github.com/bromite/bromite/issues/1570
+  AutofillAgent* agent = autofill_agent_.get();
+  if (agent)
+    agent->TrackAutofilledElement(element);
 }
 
 void PasswordAutofillAgent::FillPasswordSuggestion(
diff --git a/components/autofill/core/browser/autofill_driver.h b/components/autofill/core/browser/autofill_driver.h
--- a/components/autofill/core/browser/autofill_driver.h
+++ b/components/autofill/core/browser/autofill_driver.h
@@ -77,6 +77,8 @@ class AutofillDriver {
   // Returns the AutofillManager owned by the AutofillDriver.
   virtual AutofillManager& GetAutofillManager() = 0;
 
+  virtual raw_ptr<AutofillManager> secondary_autofill_manager() = 0;
+
   // Returns whether the AutofillDriver instance is associated with an active
   // frame in the MPArch sense.
   virtual bool IsInActiveFrame() const = 0;
diff --git a/components/autofill/core/browser/autofill_manager.h b/components/autofill/core/browser/autofill_manager.h
--- a/components/autofill/core/browser/autofill_manager.h
+++ b/components/autofill/core/browser/autofill_manager.h
@@ -191,6 +191,8 @@ class AutofillManager
 
   ~AutofillManager() override;
 
+  virtual bool IsAndroidAutofill() const = 0;
+
   // The following will fail a DCHECK if called for a prerendered main frame.
   AutofillClient& client() {
     DCHECK(!driver().IsPrerendering());
diff --git a/components/autofill/core/browser/browser_autofill_manager.cc b/components/autofill/core/browser/browser_autofill_manager.cc
--- a/components/autofill/core/browser/browser_autofill_manager.cc
+++ b/components/autofill/core/browser/browser_autofill_manager.cc
@@ -595,6 +595,8 @@ BrowserAutofillManager::~BrowserAutofillManager() {
   // (due to a navigation).
 }
 
+bool BrowserAutofillManager::IsAndroidAutofill() const { return false; }
+
 base::WeakPtr<AutofillManager> BrowserAutofillManager::GetWeakPtr() {
   return weak_ptr_factory_.GetWeakPtr();
 }
diff --git a/components/autofill/core/browser/browser_autofill_manager.h b/components/autofill/core/browser/browser_autofill_manager.h
--- a/components/autofill/core/browser/browser_autofill_manager.h
+++ b/components/autofill/core/browser/browser_autofill_manager.h
@@ -140,6 +140,8 @@ class BrowserAutofillManager : public AutofillManager {
 
   ~BrowserAutofillManager() override;
 
+  bool IsAndroidAutofill() const override;
+
   // Whether the |field| should show an entry to scan a credit card.
   virtual bool ShouldShowScanCreditCard(const FormData& form,
                                         const FormFieldData& field) const;
diff --git a/components/autofill/core/common/autofill_features.cc b/components/autofill/core/common/autofill_features.cc
--- a/components/autofill/core/common/autofill_features.cc
+++ b/components/autofill/core/common/autofill_features.cc
@@ -692,15 +692,6 @@ const base::FeatureParam<int>
     kAutofillEnableCacheForRegexMatchingCacheSizeParam{
         &kAutofillEnableCacheForRegexMatching, "cache_size", 300};
 
-#if BUILDFLAG(IS_ANDROID)
-// Controls the whether the Chrome may provide a virtual view structure for
-// Android Autofill.
-BASE_FEATURE(kAutofillVirtualViewStructureAndroid,
-             "AutofillVirtualViewStructureAndroid",
-             base::FEATURE_DISABLED_BY_DEFAULT);
-
-#endif  // BUILDFLAG(IS_ANDROID)
-
 namespace test {
 
 // Testing tool that collects metrics during a run of the captured site tests
diff --git a/components/autofill/core/common/autofill_features.h b/components/autofill/core/common/autofill_features.h
--- a/components/autofill/core/common/autofill_features.h
+++ b/components/autofill/core/common/autofill_features.h
@@ -223,15 +223,6 @@ COMPONENT_EXPORT(AUTOFILL)
 extern const base::FeatureParam<int>
     kAutofillEnableCacheForRegexMatchingCacheSizeParam;
 
-#if BUILDFLAG(IS_ANDROID)
-COMPONENT_EXPORT(AUTOFILL)
-BASE_DECLARE_FEATURE(kAutofillVirtualViewStructureAndroid);
-inline constexpr base::FeatureParam<bool>
-    kAutofillVirtualViewStructureAndroidSkipsCompatibilityCheck{
-        &kAutofillVirtualViewStructureAndroid, "skip_compatibility_check",
-        false};
-#endif  // BUILDFLAG(IS_ANDROID)
-
 #if BUILDFLAG(IS_APPLE)
 // Returns true if whether the views autofill popup feature is enabled or the
 // we're using the views browser.
diff --git a/components/autofill/core/common/autofill_prefs.cc b/components/autofill/core/common/autofill_prefs.cc
--- a/components/autofill/core/common/autofill_prefs.cc
+++ b/components/autofill/core/common/autofill_prefs.cc
@@ -64,6 +64,8 @@ void RegisterProfilePrefs(user_prefs::PrefRegistrySyncable* registry) {
   registry->RegisterBooleanPref(
       prefs::kAutofillCreditCardFidoAuthOfferCheckboxState, true);
 #endif
+  registry->RegisterBooleanPref(prefs::kAutofillAndroidEnabled, true);
+  registry->RegisterBooleanPref(prefs::kAutofillAndroidIncognitoEnabled, false);
   registry->RegisterIntegerPref(prefs::kAutocompleteLastVersionRetentionPolicy,
                                 0);
   registry->RegisterStringPref(prefs::kAutofillUploadEncodingSeed, "");
diff --git a/components/autofill/core/common/autofill_prefs.h b/components/autofill/core/common/autofill_prefs.h
--- a/components/autofill/core/common/autofill_prefs.h
+++ b/components/autofill/core/common/autofill_prefs.h
@@ -87,6 +87,11 @@ inline constexpr char kAutofillUploadEventsLastResetTimestamp[] =
 // retention policy was run.
 inline constexpr char kAutocompleteLastVersionRetentionPolicy[] =
     "autocomplete.retention_policy_last_version";
+// Boolean that is true to enable native Android Autofill
+inline constexpr char kAutofillAndroidEnabled[] =
+    "autofill.android_autofill_enabled";
+inline constexpr char kAutofillAndroidIncognitoEnabled[] =
+    "autofill.android_autofill_incognito_enabled";
 #if BUILDFLAG(IS_MAC) || BUILDFLAG(IS_WIN) || BUILDFLAG(IS_ANDROID) || \
     BUILDFLAG(IS_IOS)
 // Boolean that is set when payment methods mandatory re-auth is enabled by the
diff --git a/components/embedder_support/android/java/src/org/chromium/components/embedder_support/view/ContentView.java b/components/embedder_support/android/java/src/org/chromium/components/embedder_support/view/ContentView.java
--- a/components/embedder_support/android/java/src/org/chromium/components/embedder_support/view/ContentView.java
+++ b/components/embedder_support/android/java/src/org/chromium/components/embedder_support/view/ContentView.java
@@ -43,6 +43,12 @@ import org.chromium.ui.dragdrop.DragEventDispatchHelper.DragEventDispatchDestina
 
 import java.util.function.Supplier;
 
+import android.os.Build;
+import org.chromium.base.Log;
+import android.util.SparseArray;
+import android.view.autofill.AutofillValue;
+import org.chromium.ui.base.ViewAndroidDelegate;
+
 /**
  * The containing view for {@link WebContents} that exists in the Android UI hierarchy and exposes
  * the various {@link View} functionality to it.
@@ -97,6 +103,8 @@ public class ContentView extends FrameLayout
             Context context,
             @Nullable EventOffsetHandler eventOffsetHandler,
             @Nullable WebContents webContents) {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O)
+            return new ContentViewWithAutofill(context, eventOffsetHandler, webContents);
         return new ContentView(context, eventOffsetHandler, webContents);
     }
 
@@ -660,4 +668,43 @@ public class ContentView extends FrameLayout
         mDragDropEventOffsetHandler.onPostDispatchDragEvent(event.getAction());
         return ret;
     }
+
+    /**
+    * API level 26 implementation that includes autofill.
+    */
+    public static class ContentViewWithAutofill extends ContentView {
+        private ViewAndroidDelegate viewAndroidDelegate;
+
+        private ContentViewWithAutofill(Context context, EventOffsetHandler eventOffsetHandler, WebContents webContents) {
+            super(context, eventOffsetHandler, webContents);
+
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+                // The Autofill system-level infrastructure has heuristics for which Views it considers
+                // important for autofill; only these Views will be queried for their autofill
+                // structure on notifications that a new (virtual) View was entered. By default,
+                // FrameLayout is not considered important for autofill. Thus, for ContentView to be
+                // queried for its autofill structure, we must explicitly inform the autofill system
+                // that this View is important for autofill.
+                setImportantForAutofill(View.IMPORTANT_FOR_AUTOFILL_YES);
+            }
+        }
+
+        @Override
+        public void setWebContents(WebContents webContents) {
+            viewAndroidDelegate = webContents.getViewAndroidDelegate();
+            super.setWebContents(webContents);
+        }
+
+        @Override
+        public void onProvideAutofillVirtualStructure(ViewStructure structure, int flags) {
+            if (viewAndroidDelegate != null)
+                viewAndroidDelegate.onProvideAutofillVirtualStructure(structure, flags);
+        }
+
+        @Override
+        public void autofill(final SparseArray<AutofillValue> values) {
+            if (viewAndroidDelegate != null)
+                viewAndroidDelegate.autofill(values);
+        }
+    }
 }
diff --git a/ui/android/java/src/org/chromium/ui/base/ViewAndroidDelegate.java b/ui/android/java/src/org/chromium/ui/base/ViewAndroidDelegate.java
--- a/ui/android/java/src/org/chromium/ui/base/ViewAndroidDelegate.java
+++ b/ui/android/java/src/org/chromium/ui/base/ViewAndroidDelegate.java
@@ -35,6 +35,10 @@ import org.chromium.ui.dragdrop.DragStateTracker;
 import org.chromium.ui.dragdrop.DropDataAndroid;
 import org.chromium.ui.mojom.CursorType;
 
+import android.util.SparseArray;
+import android.view.autofill.AutofillValue;
+import android.view.ViewStructure;
+
 /** Class to acquire, position, and remove anchor views from the implementing View. */
 @JNINamespace("ui")
 public class ViewAndroidDelegate {
--
