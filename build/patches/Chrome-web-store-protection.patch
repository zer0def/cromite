From: uazo <uazo@users.noreply.github.com>
Date: Thu, 28 Dec 2023 14:58:09 +0000
Subject: Chrome web store protection

The amount of information sent is minimized without disabling
the ability to install extensions (which is under user control)
It became possible to activate the autoupdate of extensions by sending the minimum of values.
Installation with the chrome web store is allowed, but the website
by default cannot retrieve the list of installed extensions and their status (under flag)
All http calls related to requesting and downloading updates are cookie-free,
but the ip and the list of extensions are traceable, that information cannot be omitted.
Auto-update is disabled by default: it is possible to activate it with chrome://extensions/

License: GPL-2.0-or-later - https://spdx.org/licenses/GPL-2.0-or-later.html
---
 chrome/app/extensions_strings.grdp            |  6 +++
 .../developer_private_api.cc                  | 37 ++++++++++++-
 .../developer_private/developer_private_api.h |  3 ++
 .../webstore_private/webstore_private_api.cc  | 12 ++++-
 .../extensions/extension_system_impl.cc       |  2 +
 .../chrome_extension_downloader_factory.cc    |  1 -
 .../extensions/updater/extension_updater.cc   | 40 ++++++++------
 .../extensions/updater/extension_updater.h    |  4 ++
 .../extensions/webstore_install_helper.cc     |  2 +-
 .../browser/extensions/webstore_installer.cc  |  2 +-
 .../browser/resources/extensions/manager.html |  1 +
 .../browser/resources/extensions/manager.ts   |  7 +++
 .../browser/resources/extensions/service.ts   |  5 ++
 .../browser/resources/extensions/toolbar.html | 12 +++++
 .../browser/resources/extensions/toolbar.ts   | 20 +++++++
 .../resources/webstore_app/manifest.json      |  7 +--
 .../ui/webui/extensions/extensions_ui.cc      |  8 +++
 .../chrome_update_query_params_delegate.cc    |  8 +--
 .../extensions/api/developer_private.idl      |  2 +
 .../update_client/update_query_params.cc      |  7 ++-
 .../about_flags_cc/Webstore-protection.inc    | 19 +++++++
 .../browser/api/management/management_api.cc  | 50 +++++++++++------
 .../browser/updater/extension_downloader.cc   | 53 +++++++------------
 .../browser/updater/extension_downloader.h    |  1 -
 .../browser/updater/manifest_fetch_data.cc    |  8 +--
 .../browser/updater/safe_manifest_parser.cc   |  1 +
 extensions/common/extension_features.cc       | 15 ++++++
 extensions/common/extension_features.h        |  4 ++
 .../definitions/developer_private.d.ts        |  4 +-
 29 files changed, 249 insertions(+), 92 deletions(-)
 create mode 100644 cromite_flags/chrome/browser/about_flags_cc/Webstore-protection.inc

diff --git a/chrome/app/extensions_strings.grdp b/chrome/app/extensions_strings.grdp
--- a/chrome/app/extensions_strings.grdp
+++ b/chrome/app/extensions_strings.grdp
@@ -76,6 +76,12 @@
   <message name="IDS_EXTENSIONS_DEVELOPER_MODE" desc="The text displayed next to the checkbox to toggle developer mode in the extensions page.">
     Developer mode
   </message>
+  <message name="IDS_EXTENSIONS_EXTENSION_UPDATE_ENABLED" desc="The text displayed next to the checkbox to toggle extension auto update.">
+    Enable Auto-Update
+  </message>
+  <message name="IDS_EXTENSIONS_EXTENSION_UPDATE_ENABLED_NR" desc="The text displayed next to the checkbox to toggle extension auto update.">
+    Need restart
+  </message>
   <message name="IDS_EXTENSIONS_DISABLED_UPDATE_REQUIRED_BY_POLICY" desc="Text shown in the extensions settings for extensions disabled due to minimum version requirement from enterprise policy">
     This extension is outdated and disabled by enterprise policy. It might become enabled automatically when a newer version is available.
   </message>
diff --git a/chrome/browser/extensions/api/developer_private/developer_private_api.cc b/chrome/browser/extensions/api/developer_private/developer_private_api.cc
--- a/chrome/browser/extensions/api/developer_private/developer_private_api.cc
+++ b/chrome/browser/extensions/api/developer_private/developer_private_api.cc
@@ -125,6 +125,12 @@
 #include "url/gurl.h"
 #include "url/origin.h"
 
+#include "chrome/browser/about_flags.h"
+#include "chrome/browser/browser_process.h"
+#include "components/flags_ui/pref_service_flags_storage.h"
+#include "components/flags_ui/feature_entry.h"
+#include "components/flags_ui/flags_storage.h"
+
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
 #include "components/supervised_user/core/browser/supervised_user_preferences.h"
 #endif  // BUILDFLAG(ENABLE_SUPERVISED_USERS)
@@ -520,9 +526,32 @@ std::unique_ptr<developer::ProfileInfo> DeveloperPrivateAPI::CreateProfileInfo(
   info->can_load_unpacked =
       ExtensionManagementFactory::GetForBrowserContext(profile)
           ->HasAllowlistedExtension();
+  info->is_extension_autoupdate_enabled = DeveloperPrivateAPI::IsExtensionAutoupdateEnabled();
   return info;
 }
 
+// static
+bool DeveloperPrivateAPI::IsExtensionAutoupdateEnabled() {
+  const std::string enabled_entry = "enable-extension-autoupdate@1";
+  flags_ui::PrefServiceFlagsStorage flags_storage(
+      g_browser_process->local_state());
+  std::set<std::string> entries = flags_storage.GetFlags();
+  return entries.count(enabled_entry) > 0;
+}
+
+// static
+void DeveloperPrivateAPI::SetExtensionAutoupdateEnabled(bool enable) {
+  flags_ui::PrefServiceFlagsStorage flags_storage(
+      g_browser_process->local_state());
+  if (enable) {
+    about_flags::SetFeatureEntryEnabled(
+      &flags_storage, "enable-extension-autoupdate@1", true);
+  } else {
+    about_flags::SetFeatureEntryEnabled(
+      &flags_storage, "enable-extension-autoupdate", false);
+  }
+}
+
 template <>
 void BrowserContextKeyedAPIFactory<
     DeveloperPrivateAPI>::DeclareFactoryDependencies() {
@@ -951,6 +980,7 @@ ExtensionFunction::ResponseAction DeveloperPrivateAutoUpdateFunction::Run() {
     ExtensionUpdater::CheckParams params;
     params.fetch_priority = DownloadFetchPriority::kForeground;
     params.install_immediately = true;
+    params.user_initiated = true;
     params.callback =
         base::BindOnce(&DeveloperPrivateAutoUpdateFunction::OnComplete, this);
     updater->CheckNow(std::move(params));
@@ -1090,7 +1120,7 @@ DeveloperPrivateUpdateProfileConfigurationFunction::Run() {
 
   const developer::ProfileConfigurationUpdate& update = params->update;
 
-  if (update.in_developer_mode) {
+  if (update.in_developer_mode.has_value() && update.in_developer_mode) {
     Profile* profile = Profile::FromBrowserContext(browser_context());
     CHECK(profile);
 #if BUILDFLAG(ENABLE_SUPERVISED_USERS)
@@ -1102,6 +1132,11 @@ DeveloperPrivateUpdateProfileConfigurationFunction::Run() {
     util::SetDeveloperModeForProfile(profile, *update.in_developer_mode);
   }
 
+  if (update.is_extension_autoupdate_enabled.has_value()) {
+    DeveloperPrivateAPI::SetExtensionAutoupdateEnabled(
+      *update.is_extension_autoupdate_enabled);
+  }
+
   return RespondNow(NoArguments());
 }
 
diff --git a/chrome/browser/extensions/api/developer_private/developer_private_api.h b/chrome/browser/extensions/api/developer_private/developer_private_api.h
--- a/chrome/browser/extensions/api/developer_private/developer_private_api.h
+++ b/chrome/browser/extensions/api/developer_private/developer_private_api.h
@@ -233,6 +233,9 @@ class DeveloperPrivateAPI : public BrowserContextKeyedAPI,
   static std::unique_ptr<api::developer_private::ProfileInfo> CreateProfileInfo(
       Profile* profile);
 
+  static bool IsExtensionAutoupdateEnabled();
+  static void SetExtensionAutoupdateEnabled(bool enable);
+
   // Convenience method to get the DeveloperPrivateAPI for a profile.
   static DeveloperPrivateAPI* Get(content::BrowserContext* context);
 
diff --git a/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc b/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
--- a/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
+++ b/chrome/browser/extensions/api/webstore_private/webstore_private_api.cc
@@ -60,6 +60,7 @@
 #include "extensions/browser/extension_system.h"
 #include "extensions/browser/extension_util.h"
 #include "extensions/common/extension.h"
+#include "extensions/common/extension_features.h"
 #include "extensions/common/manifest.h"
 #include "extensions/common/manifest_constants.h"
 #include "extensions/common/manifest_handlers/permissions_parser.h"
@@ -230,12 +231,16 @@ WebstorePrivateApi::Delegate* test_delegate = nullptr;
 // there was previously stored data, or an empty string otherwise. The Set will
 // overwrite any previous login.
 std::string GetWebstoreLogin(Profile* profile) {
+  if (!base::FeatureList::IsEnabled(extensions_features::kEnableExtensionManagementToChromeStore))
+    return std::string();
   if (profile->GetPrefs()->HasPrefPath(kWebstoreLogin))
     return profile->GetPrefs()->GetString(kWebstoreLogin);
   return std::string();
 }
 
 void SetWebstoreLogin(Profile* profile, const std::string& login) {
+  if (!base::FeatureList::IsEnabled(extensions_features::kEnableExtensionManagementToChromeStore))
+    return;
   profile->GetPrefs()->SetString(kWebstoreLogin, login);
 }
 
@@ -245,6 +250,8 @@ void RecordWebstoreExtensionInstallResult(bool success) {
 
 api::webstore_private::ExtensionInstallStatus
 ConvertExtensionInstallStatusForAPI(ExtensionInstallStatus status) {
+  if (!base::FeatureList::IsEnabled(extensions_features::kEnableExtensionManagementToChromeStore))
+    return api::webstore_private::ExtensionInstallStatus::kInstallable;
   switch (status) {
     case kCanRequest:
       return api::webstore_private::ExtensionInstallStatus::kCanRequest;
@@ -1163,7 +1170,8 @@ ExtensionFunction::ResponseAction
 WebstorePrivateIsInIncognitoModeFunction::Run() {
   Profile* profile = Profile::FromBrowserContext(browser_context());
   return RespondNow(ArgumentList(IsInIncognitoMode::Results::Create(
-      profile != profile->GetOriginalProfile())));
+      base::FeatureList::IsEnabled(extensions_features::kEnableExtensionManagementToChromeStore)
+      && profile != profile->GetOriginalProfile())));
 }
 
 WebstorePrivateIsPendingCustodianApprovalFunction::
@@ -1263,6 +1271,8 @@ WebstorePrivateGetReferrerChainFunction::Run() {
       recent_navigations_to_collect);
 
   std::string serialized_referrer_proto = request.SerializeAsString();
+  if (!base::FeatureList::IsEnabled(extensions_features::kEnableExtensionManagementToChromeStore))
+    serialized_referrer_proto = "";
   // Base64 encode the proto to avoid issues with base::Value rejecting strings
   // which are not valid UTF8.
   base::Base64Encode(serialized_referrer_proto, &serialized_referrer_proto);
diff --git a/chrome/browser/extensions/extension_system_impl.cc b/chrome/browser/extensions/extension_system_impl.cc
--- a/chrome/browser/extensions/extension_system_impl.cc
+++ b/chrome/browser/extensions/extension_system_impl.cc
@@ -56,6 +56,7 @@
 #include "extensions/browser/updater/uninstall_ping_sender.h"
 #include "extensions/browser/user_script_manager.h"
 #include "extensions/common/constants.h"
+#include "extensions/common/extension_features.h"
 #include "extensions/common/features/feature_channel.h"
 #include "extensions/common/manifest_url_handlers.h"
 #include "ui/message_center/public/cpp/notifier_id.h"
@@ -83,6 +84,7 @@ UninstallPingSender::FilterResult ShouldSendUninstallPing(
     Profile* profile,
     const Extension* extension,
     UninstallReason reason) {
+  if ((true)) return UninstallPingSender::DO_NOT_SEND_PING;
   ExtensionManagement* extension_management =
       ExtensionManagementFactory::GetForBrowserContext(profile);
   if (extension && (extension->from_webstore() ||
diff --git a/chrome/browser/extensions/updater/chrome_extension_downloader_factory.cc b/chrome/browser/extensions/updater/chrome_extension_downloader_factory.cc
--- a/chrome/browser/extensions/updater/chrome_extension_downloader_factory.cc
+++ b/chrome/browser/extensions/updater/chrome_extension_downloader_factory.cc
@@ -49,7 +49,6 @@ ChromeExtensionDownloaderFactory::CreateForURLLoaderFactory(
     manifest_query_params += "&testrequest=1";
   }
   downloader->set_manifest_query_params(manifest_query_params);
-  downloader->set_ping_enabled_domain("google.com");
   return downloader;
 }
 
diff --git a/chrome/browser/extensions/updater/extension_updater.cc b/chrome/browser/extensions/updater/extension_updater.cc
--- a/chrome/browser/extensions/updater/extension_updater.cc
+++ b/chrome/browser/extensions/updater/extension_updater.cc
@@ -43,6 +43,7 @@
 #include "extensions/browser/updater/extension_update_data.h"
 #include "extensions/common/constants.h"
 #include "extensions/common/extension.h"
+#include "extensions/common/extension_features.h"
 #include "extensions/common/extension_set.h"
 #include "extensions/common/extension_updater_uma.h"
 #include "extensions/common/extension_urls.h"
@@ -197,6 +198,10 @@ void ExtensionUpdater::Start() {
   DCHECK(!weak_ptr_factory_.HasWeakPtrs());
   DCHECK(registry_);
   alive_ = true;
+  if (first_start_) {
+    first_start_ = false;
+    CheckSoon();
+  }
   // Check soon, and set up the first delayed check.
   if (!g_skip_scheduled_checks_for_tests) {
     if (g_should_immediately_update)
@@ -329,7 +334,8 @@ void ExtensionUpdater::AddToDownloader(
     const Extension& extension = **extension_iter;
     const ExtensionId& extension_id = extension.id();
     if (!Manifest::IsAutoUpdateableLocation(extension.location())) {
-      VLOG(2) << "Extension " << extension_id << " is not auto updateable";
+      LOG(INFO) << "Extension " << extension_id << " is not auto updateable: "
+                << "location=" << extension.location();
       continue;
     }
     // An extension might be overwritten by policy, and have its update url
@@ -343,7 +349,7 @@ void ExtensionUpdater::AddToDownloader(
       continue;
     }
 
-    if (CanUseUpdateService(extension_id)) {
+    if ((false) && CanUseUpdateService(extension_id)) {
       update_check_params->update_info[extension_id] = ExtensionUpdateData();
     } else if (AddExtensionToDownloader(extension, request_id,
                                         fetch_priority)) {
@@ -381,6 +387,12 @@ bool ExtensionUpdater::AddExtensionToDownloader(
 }
 
 void ExtensionUpdater::CheckNow(CheckParams params) {
+  if (!params.user_initiated &&
+      !base::FeatureList::IsEnabled(
+            extensions_features::kEnableExtensionAutoupdate)) {
+    LOG(INFO) << "Extensions autoupdate is disabled.";
+    return;
+  }
   if (params.ids.empty()) {
     // Checking all extensions. Cancel pending DoCheckSoon() call if there's
     // one, as it would be redundant.
@@ -389,7 +401,7 @@ void ExtensionUpdater::CheckNow(CheckParams params) {
 
   int request_id = next_request_id_++;
 
-  VLOG(2) << "Starting update check " << request_id;
+  LOG(INFO) << "Starting extensions update check id: " << request_id;
   if (params.ids.empty())
     NotifyStarted();
 
@@ -461,7 +473,7 @@ void ExtensionUpdater::CheckNow(CheckParams params) {
                                      << " is not a corrupt reinstall";
         update_check_params.update_info[pending_id] = ExtensionUpdateData();
       } else if (!Manifest::IsAutoUpdateableLocation(info->install_source())) {
-        VLOG(2) << "Extension " << pending_id << " is not auto updateable";
+        LOG(INFO) << "Extension " << pending_id << " is not auto updateable";
         continue;
       }
       // We have to mark high-priority extensions (such as policy-forced
@@ -471,7 +483,7 @@ void ExtensionUpdater::CheckNow(CheckParams params) {
       // See https://crbug.com/904600 and https://crbug.com/965686.
       const bool is_high_priority_extension_pending =
           pending_extension_manager->HasHighPriorityPendingExtension();
-      if (CanUseUpdateService(pending_id)) {
+      if ((false) && CanUseUpdateService(pending_id)) {
         update_check_params.update_info[pending_id].is_corrupt_reinstall =
             is_corrupt_reinstall;
         if (is_corrupt_reinstall) {
@@ -492,6 +504,8 @@ void ExtensionUpdater::CheckNow(CheckParams params) {
           LOG(WARNING) << "Corrupt extension with id " << pending_id
                        << " will be reinstalled with ExtensionDownloader.";
         }
+        LOG(INFO) << "Extension " << pending_id << " is auto updateable "
+                  << "from " << info->update_url();
       } else {
         InstallStageTracker::Get(profile_)->ReportFailure(
             pending_id,
@@ -504,13 +518,6 @@ void ExtensionUpdater::CheckNow(CheckParams params) {
     AddToDownloader(&registry_->disabled_extensions(), pending_ids, request_id,
                     params.fetch_priority, &update_check_params);
     ExtensionSet remotely_disabled_extensions;
-    for (auto extension : registry_->blocklisted_extensions()) {
-      if (blocklist_prefs::HasOmahaBlocklistState(
-              extension->id(), BitMapBlocklistState::BLOCKLISTED_MALWARE,
-              extension_prefs_)) {
-        remotely_disabled_extensions.Insert(extension);
-      }
-    }
     AddToDownloader(&remotely_disabled_extensions, pending_ids, request_id,
                     params.fetch_priority, &update_check_params);
   } else {
@@ -518,7 +525,7 @@ void ExtensionUpdater::CheckNow(CheckParams params) {
       const Extension* extension =
           registry_->GetExtensionById(id, ExtensionRegistry::EVERYTHING);
       if (extension) {
-        if (CanUseUpdateService(id)) {
+        if ((false) && CanUseUpdateService(id)) {
           update_check_params.update_info[id] = ExtensionUpdateData();
         } else if (AddExtensionToDownloader(*extension, request_id,
                                             params.fetch_priority)) {
@@ -659,7 +666,7 @@ void ExtensionUpdater::OnExtensionDownloadFinished(
       file.extension_id, InstallStageTracker::Stage::INSTALLING);
   UpdatePingData(file.extension_id, ping);
 
-  VLOG(2) << download_url << " written to " << file.path.value();
+  LOG(INFO) << download_url << " written to " << file.path.value();
 
   FetchedCRXFile fetched(file, file_ownership_passed, request_ids,
                          std::move(callback));
@@ -670,6 +677,7 @@ void ExtensionUpdater::OnExtensionDownloadFinished(
 
 bool ExtensionUpdater::GetPingDataForExtension(const ExtensionId& id,
                                                DownloadPingData* ping_data) {
+  if ((true)) return false;
   DCHECK(alive_);
   ping_data->rollcall_days =
       CalculatePingDaysForExtension(extension_prefs_->LastPingDay(id));
@@ -768,7 +776,7 @@ bool ExtensionUpdater::CanUseUpdateService(
 void ExtensionUpdater::InstallCRXFile(FetchedCRXFile crx_file) {
   std::set<int> request_ids;
 
-  VLOG(2) << "updating " << crx_file.info.extension_id << " with "
+  LOG(INFO) << "Updating " << crx_file.info.extension_id << " with "
           << crx_file.info.path.value();
 
   // The ExtensionService is now responsible for cleaning up the temp file
@@ -877,7 +885,7 @@ void ExtensionUpdater::NotifyIfFinished(int request_id) {
   InProgressCheck& request = requests_in_progress_[request_id];
   if (!request.in_progress_ids.empty() || request.awaiting_update_service)
     return;  // This request is not done yet.
-  VLOG(2) << "Finished update check " << request_id;
+  LOG(INFO) << "Finished update check id: " << request_id;
   if (!request.callback.is_null())
     std::move(request.callback).Run();
   requests_in_progress_.erase(request_id);
diff --git a/chrome/browser/extensions/updater/extension_updater.h b/chrome/browser/extensions/updater/extension_updater.h
--- a/chrome/browser/extensions/updater/extension_updater.h
+++ b/chrome/browser/extensions/updater/extension_updater.h
@@ -80,6 +80,8 @@ class ExtensionUpdater : public ExtensionDownloaderDelegate {
     // right away.
     bool install_immediately = false;
 
+    bool user_initiated = false;
+
     // An extension update check can be originated by a user or by a scheduled
     // task. When the value of |fetch_priority| is FOREGROUND, the update
     // request was initiated by a user.
@@ -327,6 +329,8 @@ class ExtensionUpdater : public ExtensionDownloaderDelegate {
   base::TimeDelta frequency_;
   bool will_check_soon_ = false;
 
+  bool first_start_ = true;
+
   raw_ptr<ExtensionPrefs, DanglingUntriaged> extension_prefs_ = nullptr;
   raw_ptr<PrefService, DanglingUntriaged> prefs_ = nullptr;
   raw_ptr<Profile, DanglingUntriaged> profile_ = nullptr;
diff --git a/chrome/browser/extensions/webstore_install_helper.cc b/chrome/browser/extensions/webstore_install_helper.cc
--- a/chrome/browser/extensions/webstore_install_helper.cc
+++ b/chrome/browser/extensions/webstore_install_helper.cc
@@ -46,7 +46,7 @@ void WebstoreInstallHelper::Start(
   data_decoder::DataDecoder::ParseJsonIsolated(
       manifest_, base::BindOnce(&WebstoreInstallHelper::OnJSONParsed, this));
 
-  if (icon_url_.is_empty()) {
+  if ((true) || icon_url_.is_empty()) {
     icon_decode_complete_ = true;
   } else {
     // No existing |icon_fetcher_| to avoid unbalanced AddRef().
diff --git a/chrome/browser/extensions/webstore_installer.cc b/chrome/browser/extensions/webstore_installer.cc
--- a/chrome/browser/extensions/webstore_installer.cc
+++ b/chrome/browser/extensions/webstore_installer.cc
@@ -624,7 +624,7 @@ void WebstoreInstaller::StartDownload(const std::string& extension_id,
       download_url_, render_process_host_id, render_frame_host->GetRoutingID(),
       traffic_annotation));
   params->set_file_path(file);
-  if (controller.GetVisibleEntry()) {
+  if ((false) && controller.GetVisibleEntry()) {
     content::Referrer referrer = content::Referrer::SanitizeForRequest(
         download_url_,
         content::Referrer(controller.GetVisibleEntry()->GetURL(),
diff --git a/chrome/browser/resources/extensions/manager.html b/chrome/browser/resources/extensions/manager.html
--- a/chrome/browser/resources/extensions/manager.html
+++ b/chrome/browser/resources/extensions/manager.html
@@ -64,6 +64,7 @@
 <extensions-drop-overlay drag-enabled="[[inDevMode]]">
 </extensions-drop-overlay>
 <extensions-toolbar id="toolbar" in-dev-mode="[[inDevMode]]"
+    is-ext-update-enabled="[[isExtUpdateEnabled]]"
     can-load-unpacked="[[canLoadUnpacked]]"
     is-child-account="[[isChildAccount_]]"
     dev-mode-controlled-by-policy="[[devModeControlledByPolicy]]"
diff --git a/chrome/browser/resources/extensions/manager.ts b/chrome/browser/resources/extensions/manager.ts
--- a/chrome/browser/resources/extensions/manager.ts
+++ b/chrome/browser/resources/extensions/manager.ts
@@ -121,6 +121,11 @@ export class ExtensionsManagerElement extends ExtensionsManagerElementBase {
         value: () => loadTimeData.getBoolean('inDevMode'),
       },
 
+      isExtUpdateEnabled: {
+        type: Boolean,
+        value: () => loadTimeData.getBoolean('isExtUpdateEnabled'),
+      },
+
       showActivityLog: {
         type: Boolean,
         value: () => loadTimeData.getBoolean('showActivityLog'),
@@ -222,6 +227,7 @@ export class ExtensionsManagerElement extends ExtensionsManagerElementBase {
   canLoadUnpacked: boolean;
   delegate: Service;
   inDevMode: boolean;
+  isExtUpdateEnabled: boolean;
   showActivityLog: boolean;
   enableEnhancedSiteControls: boolean;
   devModeControlledByPolicy: boolean;
@@ -292,6 +298,7 @@ export class ExtensionsManagerElement extends ExtensionsManagerElementBase {
               profileInfo.isDeveloperModeControlledByPolicy;
           this.inDevMode = profileInfo.inDeveloperMode;
           this.canLoadUnpacked = profileInfo.canLoadUnpacked;
+          this.isExtUpdateEnabled = profileInfo.isExtensionAutoupdateEnabled;
         };
     service.getProfileStateChangedTarget().addListener(onProfileStateChanged);
     service.getProfileConfiguration().then(onProfileStateChanged);
diff --git a/chrome/browser/resources/extensions/service.ts b/chrome/browser/resources/extensions/service.ts
--- a/chrome/browser/resources/extensions/service.ts
+++ b/chrome/browser/resources/extensions/service.ts
@@ -284,6 +284,11 @@ export class Service implements ServiceInterface {
         {inDeveloperMode: inDevMode});
   }
 
+  setExtUpdateEnabled(enabled: boolean) {
+     chrome.developerPrivate.updateProfileConfiguration(
+         {isExtensionAutoupdateEnabled: enabled});
+  }
+
   loadUnpacked(): Promise<boolean> {
     return this.loadUnpackedHelper_();
   }
diff --git a/chrome/browser/resources/extensions/toolbar.html b/chrome/browser/resources/extensions/toolbar.html
--- a/chrome/browser/resources/extensions/toolbar.html
+++ b/chrome/browser/resources/extensions/toolbar.html
@@ -63,6 +63,11 @@
     margin-inline-end: 16px;
   }
 
+  #need-update {
+    color: red;
+    margin-inline: 0px;
+  }
+
   cr-toolbar {
     --cr-toolbar-center-basis: 680px;
     --cr-toolbar-field-max-width: var(--cr-toolbar-center-basis);
@@ -87,6 +92,13 @@
         checked="[[inDevMode]]" aria-labelledby="devModeLabel">
     </cr-toggle>
   </div>
+  <div class="more-actions">
+    <span>$i18n{toolbarExtensionUpdateEnabled}
+      <span id="need-update" hidden="[[!shouldShowRelaunchDialog]]">$i18n{toolbarExtensionUpdateEnabledNeedRestart}</span>
+    </span>
+    <cr-toggle on-change="onExtUpdateEnabledChanged_" checked="[[isExtUpdateEnabled]]">
+    </cr-toggle>
+  </div>
 </cr-toolbar>
 <template is="dom-if" if="[[showPackDialog_]]" restamp>
   <extensions-pack-dialog delegate="[[delegate]]"
diff --git a/chrome/browser/resources/extensions/toolbar.ts b/chrome/browser/resources/extensions/toolbar.ts
--- a/chrome/browser/resources/extensions/toolbar.ts
+++ b/chrome/browser/resources/extensions/toolbar.ts
@@ -26,6 +26,8 @@ export interface ToolbarDelegate {
    */
   setProfileInDevMode(inDevMode: boolean): void;
 
+  setExtUpdateEnabled(enabled: boolean): void;
+
   /** Opens the dialog to load unpacked extensions. */
   loadUnpacked(): Promise<boolean>;
 
@@ -72,6 +74,13 @@ export class ExtensionsToolbarElement extends ExtensionsToolbarElementBase {
         reflectToAttribute: true,
       },
 
+      isExtUpdateEnabled: {
+        type: Boolean,
+        value: false,
+        observer: 'onExtUpdateEnabledChanged_',
+        reflectToAttribute: true,
+      },
+
       devModeControlledByPolicy: Boolean,
       isChildAccount: Boolean,
 
@@ -88,6 +97,7 @@ export class ExtensionsToolbarElement extends ExtensionsToolbarElementBase {
 
       expanded_: Boolean,
       showPackDialog_: Boolean,
+      shouldShowRelaunchDialog: Boolean,
 
       /**
        * Prevents initiating update while update is in progress.
@@ -99,6 +109,8 @@ export class ExtensionsToolbarElement extends ExtensionsToolbarElementBase {
   extensions: chrome.developerPrivate.ExtensionInfo[];
   delegate: ToolbarDelegate;
   inDevMode: boolean;
+  isExtUpdateEnabled: boolean;
+  shouldShowRelaunchDialog: boolean = false;
   devModeControlledByPolicy: boolean;
   isChildAccount: boolean;
 
@@ -151,6 +163,14 @@ export class ExtensionsToolbarElement extends ExtensionsToolbarElementBase {
         'Options_ToggleDeveloperMode_' + (e.detail ? 'Enabled' : 'Disabled'));
   }
 
+  private onExtUpdateEnabledChanged_(evt: Event, value: boolean, _old: boolean) {
+    if (evt instanceof Event) {
+      this.delegate.setExtUpdateEnabled(value);
+      this.shouldShowRelaunchDialog = true;
+      this.isExtUpdateEnabled = value;
+    }
+  }
+
   private onInDevModeChanged_(_current: boolean, previous: boolean) {
     const drawer = this.$.devDrawer;
     if (this.inDevMode) {
diff --git a/chrome/browser/resources/webstore_app/manifest.json b/chrome/browser/resources/webstore_app/manifest.json
--- a/chrome/browser/resources/webstore_app/manifest.json
+++ b/chrome/browser/resources/webstore_app/manifest.json
@@ -17,11 +17,6 @@
   },
   "permissions": [
     "webstorePrivate",
-    "management",
-    "system.cpu",
-    "system.display",
-    "system.memory",
-    "system.network",
-    "system.storage"
+    "management"
   ]
 }
diff --git a/chrome/browser/ui/webui/extensions/extensions_ui.cc b/chrome/browser/ui/webui/extensions/extensions_ui.cc
--- a/chrome/browser/ui/webui/extensions/extensions_ui.cc
+++ b/chrome/browser/ui/webui/extensions/extensions_ui.cc
@@ -58,6 +58,8 @@
 #include "chrome/browser/ui/webui/extensions/ash/kiosk_apps_handler.h"
 #endif
 
+#include "chrome/browser/extensions/api/developer_private/developer_private_api.h"
+
 namespace extensions {
 
 namespace {
@@ -340,6 +342,8 @@ content::WebUIDataSource* CreateAndAddExtensionsSource(Profile* profile,
     {"itemSuspiciousInstallLearnMore",
      IDS_EXTENSIONS_ADDED_WITHOUT_KNOWLEDGE_LEARN_MORE},
     {"toolbarDevMode", IDS_EXTENSIONS_DEVELOPER_MODE},
+    {"toolbarExtensionUpdateEnabled", IDS_EXTENSIONS_EXTENSION_UPDATE_ENABLED},
+    {"toolbarExtensionUpdateEnabledNeedRestart", IDS_EXTENSIONS_EXTENSION_UPDATE_ENABLED_NR},
     {"toolbarLoadUnpacked", IDS_EXTENSIONS_TOOLBAR_LOAD_UNPACKED},
     {"toolbarLoadUnpackedDone", IDS_EXTENSIONS_TOOLBAR_LOAD_UNPACKED_DONE},
     {"toolbarPack", IDS_EXTENSIONS_TOOLBAR_PACK},
@@ -417,6 +421,10 @@ content::WebUIDataSource* CreateAndAddExtensionsSource(Profile* profile,
   source->AddString("hostPermissionsLearnMoreLink",
                     chrome_extension_constants::kRuntimeHostPermissionsHelpURL);
   source->AddBoolean(kInDevModeKey, in_dev_mode);
+
+  source->AddBoolean("isExtUpdateEnabled",
+      DeveloperPrivateAPI::IsExtensionAutoupdateEnabled());
+
   source->AddBoolean(kShowActivityLogKey,
                      base::CommandLine::ForCurrentProcess()->HasSwitch(
                          ::switches::kEnableExtensionActivityLogging));
diff --git a/chrome/browser/update_client/chrome_update_query_params_delegate.cc b/chrome/browser/update_client/chrome_update_query_params_delegate.cc
--- a/chrome/browser/update_client/chrome_update_query_params_delegate.cc
+++ b/chrome/browser/update_client/chrome_update_query_params_delegate.cc
@@ -30,10 +30,10 @@ ChromeUpdateQueryParamsDelegate::GetInstance() {
 }
 
 std::string ChromeUpdateQueryParamsDelegate::GetExtraParams() {
-  return base::StrCat({"&prodchannel=",
-                       chrome::GetChannelName(chrome::WithExtendedStable(true)),
-                       "&prodversion=", version_info::GetVersionNumber(),
-                       "&lang=", GetLang()});
+  return base::StrCat({
+      "&prodversion=",
+      version_info::GetMajorVersionNumber().c_str(),
+      ".0.0.0"});
 }
 
 // static
diff --git a/chrome/common/extensions/api/developer_private.idl b/chrome/common/extensions/api/developer_private.idl
--- a/chrome/common/extensions/api/developer_private.idl
+++ b/chrome/common/extensions/api/developer_private.idl
@@ -278,6 +278,7 @@ namespace developerPrivate {
     boolean isDeveloperModeControlledByPolicy;
     boolean isIncognitoAvailable;
     boolean isChildAccount;
+    boolean isExtensionAutoupdateEnabled;
   };
 
   // DEPRECATED: Prefer ExtensionInfo.
@@ -335,6 +336,7 @@ namespace developerPrivate {
 
   dictionary ProfileConfigurationUpdate {
     boolean? inDeveloperMode;
+    boolean? isExtensionAutoupdateEnabled;
   };
 
   dictionary ExtensionCommandUpdate {
diff --git a/components/update_client/update_query_params.cc b/components/update_client/update_query_params.cc
--- a/components/update_client/update_query_params.cc
+++ b/components/update_client/update_query_params.cc
@@ -88,9 +88,8 @@ UpdateQueryParamsDelegate* g_delegate = nullptr;
 // static
 std::string UpdateQueryParams::Get(ProdId prod) {
   return base::StringPrintf(
-      "os=%s&arch=%s&os_arch=%s&nacl_arch=%s&prod=%s%s&acceptformat=crx3,puff",
-      kOs, kArch, base::SysInfo().OperatingSystemArchitecture().c_str(),
-      GetNaclArch(), GetProdIdString(prod),
+      "prod=%s%s&acceptformat=crx3",
+      GetProdIdString(prod),
       g_delegate ? g_delegate->GetExtraParams().c_str() : "");
 }
 
@@ -151,7 +150,7 @@ const char* UpdateQueryParams::GetNaclArch() {
 
 // static
 std::string UpdateQueryParams::GetProdVersion() {
-  return std::string(version_info::GetVersionNumber());
+  return version_info::GetMajorVersionNumber();
 }
 
 // static
diff --git a/cromite_flags/chrome/browser/about_flags_cc/Webstore-protection.inc b/cromite_flags/chrome/browser/about_flags_cc/Webstore-protection.inc
new file mode 100644
--- /dev/null
+++ b/cromite_flags/chrome/browser/about_flags_cc/Webstore-protection.inc
@@ -0,0 +1,19 @@
+#ifdef FLAG_SECTION
+
+#if !BUILDFLAG(IS_ANDROID)
+
+    {"enable-extension-autoupdate",
+     "Enable Extensions Autoupdate",
+     "Allows the auto-updating of installed extensions by sending the "
+     "minimum required data.", kOsDesktop,
+     FEATURE_VALUE_TYPE(extensions_features::kEnableExtensionAutoupdate)},
+
+    {"enable-extension-management-to-chrome-store",
+     "Allow full use of management api to chrome web store",
+     "When deactivated (default) allows installation but hide "
+     "to the webstore which extensions are installed on the device.", kOsDesktop,
+     FEATURE_VALUE_TYPE(extensions_features::kEnableExtensionManagementToChromeStore)},
+
+#endif // !BUILDFLAG(IS_ANDROID)
+
+#endif // ifdef FLAG_SECTION
diff --git a/extensions/browser/api/management/management_api.cc b/extensions/browser/api/management/management_api.cc
--- a/extensions/browser/api/management/management_api.cc
+++ b/extensions/browser/api/management/management_api.cc
@@ -25,6 +25,9 @@
 #include "components/supervised_user/core/common/buildflags.h"
 #include "components/supervised_user/core/common/features.h"
 #include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/url_constants.h"
 #include "extensions/browser/api/extensions_api_client.h"
 #include "extensions/browser/api/management/management_api_constants.h"
 #include "extensions/browser/disable_reason.h"
@@ -39,6 +42,7 @@
 #include "extensions/common/api/management.h"
 #include "extensions/common/error_utils.h"
 #include "extensions/common/extension.h"
+#include "extensions/common/extension_features.h"
 #include "extensions/common/extension_icon_set.h"
 #include "extensions/common/extension_urls.h"
 #include "extensions/common/manifest.h"
@@ -88,6 +92,27 @@ std::vector<std::string> CreateWarningsList(const Extension* extension) {
   return warnings_list;
 }
 
+const Extension* GetExtensionById(content::WebContents* web_contents,
+                                  content::BrowserContext* context,
+                                  const std::string& id,
+                                  int include_mask) {
+  bool enabled = base::FeatureList::IsEnabled(extensions_features::kEnableExtensionManagementToChromeStore);
+  if (content::RenderFrameHost* rfh = web_contents->GetPrimaryMainFrame()) {
+    url::Origin top_frame_origin = rfh->GetMainFrame()->GetLastCommittedOrigin();
+    std::string scheme = top_frame_origin.scheme();
+    if (scheme == content::kChromeUIScheme) {
+      enabled = true;
+    }
+  }
+  if (!enabled)
+    return nullptr;
+
+  ExtensionRegistry* registry = ExtensionRegistry::Get(context);
+  const Extension* target_extension =
+      registry->GetExtensionById(id, include_mask);
+  return target_extension;
+}
+
 std::vector<management::LaunchType> GetAvailableLaunchTypes(
     const Extension& extension,
     const ManagementAPIDelegate* delegate) {
@@ -261,6 +286,8 @@ void AddExtensionInfo(const Extension* source_extension,
                       const ExtensionSet& extensions,
                       ExtensionInfoList* extension_list,
                       content::BrowserContext* context) {
+  if (!base::FeatureList::IsEnabled(extensions_features::kEnableExtensionManagementToChromeStore))
+    return;
   for (ExtensionSet::const_iterator iter = extensions.begin();
        iter != extensions.end(); ++iter) {
     const Extension& extension = **iter;
@@ -306,10 +333,9 @@ ExtensionFunction::ResponseAction ManagementGetFunction::Run() {
   std::optional<management::Get::Params> params =
       management::Get::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params);
-  ExtensionRegistry* registry = ExtensionRegistry::Get(browser_context());
 
   const Extension* target_extension =
-      registry->GetExtensionById(params->id, ExtensionRegistry::EVERYTHING);
+      GetExtensionById(GetSenderWebContents(), browser_context(), params->id, ExtensionRegistry::EVERYTHING);
   if (!target_extension)
     return RespondNow(Error(keys::kNoExtensionError, params->id));
 
@@ -329,8 +355,7 @@ ManagementGetPermissionWarningsByIdFunction::Run() {
   EXTENSION_FUNCTION_VALIDATE(params);
 
   const Extension* extension =
-      ExtensionRegistry::Get(browser_context())
-          ->GetExtensionById(params->id, ExtensionRegistry::EVERYTHING);
+      GetExtensionById(GetSenderWebContents(), browser_context(), params->id, ExtensionRegistry::EVERYTHING);
   if (!extension)
     return RespondNow(Error(keys::kNoExtensionError, params->id));
 
@@ -396,8 +421,7 @@ ExtensionFunction::ResponseAction ManagementLaunchAppFunction::Run() {
     return RespondNow(Error(keys::kNotAllowedInKioskError));
 
   const Extension* extension =
-      ExtensionRegistry::Get(browser_context())
-          ->GetExtensionById(params->id, ExtensionRegistry::EVERYTHING);
+      GetExtensionById(GetSenderWebContents(), browser_context(), params->id, ExtensionRegistry::EVERYTHING);
   if (!extension)
     return RespondNow(Error(keys::kNoExtensionError, params->id));
   if (!extension->is_app())
@@ -432,7 +456,7 @@ ExtensionFunction::ResponseAction ManagementSetEnabledFunction::Run() {
                                               ->GetDelegate();
 
   const Extension* target_extension =
-      registry->GetExtensionById(extension_id_, ExtensionRegistry::EVERYTHING);
+      GetExtensionById(GetSenderWebContents(), browser_context(), extension_id_, ExtensionRegistry::EVERYTHING);
   if (!target_extension || !ShouldExposeViaManagementAPI(*target_extension)) {
     return RespondNow(Error(keys::kNoExtensionError, extension_id_));
   }
@@ -627,8 +651,7 @@ ExtensionFunction::ResponseAction ManagementUninstallFunctionBase::Uninstall(
                                               ->GetDelegate();
   target_extension_id_ = target_extension_id;
   const Extension* target_extension =
-      extensions::ExtensionRegistry::Get(browser_context())
-          ->GetExtensionById(target_extension_id_,
+      GetExtensionById(GetSenderWebContents(), browser_context(), target_extension_id_,
                              ExtensionRegistry::EVERYTHING);
   if (!target_extension || !ShouldExposeViaManagementAPI(*target_extension)) {
     return RespondNow(Error(keys::kNoExtensionError, target_extension_id_));
@@ -692,8 +715,7 @@ void ManagementUninstallFunctionBase::UninstallExtension() {
   // The extension can be uninstalled in another window while the UI was
   // showing. Do nothing in that case.
   const Extension* target_extension =
-      extensions::ExtensionRegistry::Get(browser_context())
-          ->GetExtensionById(target_extension_id_,
+      GetExtensionById(GetSenderWebContents(), browser_context(), target_extension_id_,
                              ExtensionRegistry::EVERYTHING);
   std::string error;
   bool success = false;
@@ -774,8 +796,7 @@ ExtensionFunction::ResponseAction ManagementCreateAppShortcutFunction::Run() {
       management::CreateAppShortcut::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params);
   const Extension* extension =
-      ExtensionRegistry::Get(browser_context())
-          ->GetExtensionById(params->id, ExtensionRegistry::EVERYTHING);
+      GetExtensionById(GetSenderWebContents(), browser_context(), params->id, ExtensionRegistry::EVERYTHING);
   if (!extension) {
     return RespondNow(Error(
         ErrorUtils::FormatErrorMessage(keys::kNoExtensionError, params->id)));
@@ -825,8 +846,7 @@ ExtensionFunction::ResponseAction ManagementSetLaunchTypeFunction::Run() {
       management::SetLaunchType::Params::Create(args());
   EXTENSION_FUNCTION_VALIDATE(params);
   const Extension* extension =
-      ExtensionRegistry::Get(browser_context())
-          ->GetExtensionById(params->id, ExtensionRegistry::EVERYTHING);
+      GetExtensionById(GetSenderWebContents(), browser_context(), params->id, ExtensionRegistry::EVERYTHING);
   const ManagementAPIDelegate* delegate = ManagementAPI::GetFactoryInstance()
                                               ->Get(browser_context())
                                               ->GetDelegate();
diff --git a/extensions/browser/updater/extension_downloader.cc b/extensions/browser/updater/extension_downloader.cc
--- a/extensions/browser/updater/extension_downloader.cc
+++ b/extensions/browser/updater/extension_downloader.cc
@@ -491,8 +491,8 @@ void ExtensionDownloader::CreateManifestLoader() {
   std::vector<base::StringPiece> id_vector(extension_ids.begin(),
                                            extension_ids.end());
   std::string id_list = base::JoinString(id_vector, ",");
-  VLOG(2) << "Fetching " << active_request->full_url() << " for " << id_list;
-  VLOG(2) << "Update interactivity: "
+  LOG(INFO) << "Fetching " << active_request->full_url() << " for " << id_list;
+  LOG(INFO) << "Update interactivity: "
           << (active_request->foreground_check()
                   ? kUpdateInteractivityForeground
                   : kUpdateInteractivityBackground);
@@ -517,7 +517,7 @@ void ExtensionDownloader::CreateManifestLoader() {
           destination: WEBSITE
         }
         policy {
-          cookies_allowed: YES
+          cookies_allowed: NO
           cookies_store: "user"
           setting:
             "This feature cannot be disabled. It is only enabled when the user "
@@ -534,6 +534,7 @@ void ExtensionDownloader::CreateManifestLoader() {
   auto resource_request = std::make_unique<network::ResourceRequest>();
   resource_request->url = active_request->full_url(),
   resource_request->load_flags = net::LOAD_DISABLE_CACHE;
+  resource_request->credentials_mode = network::mojom::CredentialsMode::kOmit;
 
   if (active_request->fetch_priority() == DownloadFetchPriority::kForeground) {
     resource_request->priority = net::MEDIUM;
@@ -542,10 +543,6 @@ void ExtensionDownloader::CreateManifestLoader() {
   // Send traffic-management headers to the webstore, and omit credentials.
   // https://bugs.chromium.org/p/chromium/issues/detail?id=647516
   if (extension_urls::IsWebstoreUpdateUrl(active_request->full_url())) {
-    resource_request->headers.SetHeader(kUpdateInteractivityHeader,
-                                        active_request->foreground_check()
-                                            ? kUpdateInteractivityForeground
-                                            : kUpdateInteractivityBackground);
     resource_request->headers.SetHeader(kUpdateAppIdHeader, id_list);
     resource_request->headers.SetHeader(
         kUpdateUpdaterHeader,
@@ -830,20 +827,6 @@ void ExtensionDownloader::HandleManifestResults(
         update.second->info);
   }
 
-  // If the manifest response included a <daystart> element, we want to save
-  // that value for any extensions which had sent a ping in the request.
-  if (fetch_data->base_url().DomainIs(kGoogleDotCom) &&
-      results->daystart_elapsed_seconds >= 0) {
-    Time day_start =
-        Time::Now() - base::Seconds(results->daystart_elapsed_seconds);
-
-    for (const ExtensionId& id : extension_ids) {
-      ExtensionDownloaderDelegate::PingResult& result = ping_results_[id];
-      result.did_ping = fetch_data->DidPing(id, ManifestFetchData::ROLLCALL);
-      result.day_start = day_start;
-    }
-  }
-
   ExtensionIdSet extension_ids_with_errors;
   for (const auto& failure : failures)
     extension_ids_with_errors.insert(failure.first.id);
@@ -865,7 +848,7 @@ ExtensionDownloader::GetUpdateAvailability(
     // extensions that have already existed in the system.
     if (!delegate_->GetExtensionExistingVersion(extension_id,
                                                 &extension_version)) {
-      VLOG(2) << extension_id << " is not installed";
+      LOG(INFO) << extension_id << " is not installed";
       return UpdateAvailability::kBadUpdateSpecification;
     }
     VLOG(2) << extension_id << " is at '" << extension_version << "'";
@@ -876,11 +859,11 @@ ExtensionDownloader::GetUpdateAvailability(
     const std::string& update_version_str = update->version;
     if (VLOG_IS_ON(2)) {
       if (update_version_str.empty())
-        VLOG(2) << "Manifest indicates " << extension_id
+        LOG(INFO) << "Manifest indicates " << extension_id
                 << " has no update (info: " << update->info.value_or("no info")
                 << ")";
       else
-        VLOG(2) << "Manifest indicates " << extension_id
+        LOG(INFO) << "Manifest indicates " << extension_id
                 << " latest version is '" << update_version_str << "'";
     }
 
@@ -890,21 +873,21 @@ ExtensionDownloader::GetUpdateAvailability(
       // we don't want it.
       if (update_version_str.empty()) {
         // If update manifest doesn't have version number => no update.
-        VLOG(2) << extension_id << " has empty version";
+        LOG(INFO) << extension_id << " has empty version";
         has_noupdate = true;
         continue;
       }
 
       const base::Version update_version(update_version_str);
       if (!update_version.IsValid()) {
-        VLOG(2) << extension_id << " has invalid version '"
+        LOG(INFO) << extension_id << " has invalid version '"
                 << update_version_str << "'";
         continue;
       }
 
       const base::Version existing_version(extension_version);
       if (update_version.CompareTo(existing_version) <= 0) {
-        VLOG(2) << extension_id << " version is not older than '"
+        LOG(INFO) << extension_id << " version is not older than '"
                 << update_version_str << "'";
         has_noupdate = true;
         continue;
@@ -925,7 +908,9 @@ ExtensionDownloader::GetUpdateAvailability(
     }
 
     // Stop checking as soon as an update for |extension_id| is found.
-    VLOG(2) << "Will try to update " << extension_id;
+    LOG(INFO) << "Will try to update " << extension_id
+              << " at " << extension_version
+              << " update to " << update_version_str;
     *update_result_out = const_cast<UpdateManifestResult*>(update);
     return UpdateAvailability::kAvailable;
   }
@@ -1170,7 +1155,7 @@ void ExtensionDownloader::CreateExtensionLoader() {
   int load_flags = net::LOAD_DISABLE_CACHE;
   bool is_secure = fetch->url.SchemeIsCryptographic();
   extension_loader_resource_request_->load_flags = load_flags;
-  if (fetch->credentials != ExtensionFetch::CREDENTIALS_COOKIES || !is_secure) {
+  if ((true) || fetch->credentials != ExtensionFetch::CREDENTIALS_COOKIES || !is_secure) {
     extension_loader_resource_request_->credentials_mode =
         network::mojom::CredentialsMode::kOmit;
   } else {
@@ -1178,7 +1163,7 @@ void ExtensionDownloader::CreateExtensionLoader() {
         net::SiteForCookies::FromUrl(fetch->url);
   }
 
-  if (fetch->credentials == ExtensionFetch::CREDENTIALS_OAUTH2_TOKEN &&
+  if ((false) && fetch->credentials == ExtensionFetch::CREDENTIALS_OAUTH2_TOKEN &&
       is_secure) {
     if (access_token_.empty()) {
       // We should try OAuth2, but we have no token cached. This
@@ -1203,7 +1188,7 @@ void ExtensionDownloader::CreateExtensionLoader() {
         base::StringPrintf("Bearer %s", access_token_.c_str()));
   }
 
-  VLOG(2) << "Starting load of " << fetch->url << " for " << fetch->id;
+  LOG(INFO) << "Starting load of " << fetch->url << " for " << fetch->id;
 
   StartExtensionLoader();
 }
@@ -1225,7 +1210,7 @@ void ExtensionDownloader::StartExtensionLoader() {
           destination: WEBSITE
         }
         policy {
-          cookies_allowed: YES
+          cookies_allowed: NO
           cookies_store: "user"
           setting:
             "This feature cannot be disabled. It is only enabled when the user "
@@ -1296,6 +1281,7 @@ void ExtensionDownloader::OnExtensionLoadComplete(base::FilePath crx_path) {
     RETRY_HISTOGRAM("CrxFetchSuccess",
                     extensions_queue_.active_request_failure_count(),
                     url);
+    LOG(INFO) << "Extension fetch success url " << url.possibly_invalid_spec();
     std::unique_ptr<ExtensionFetch> fetch_data =
         std::move(extensions_queue_.reset_active_request().fetch);
     delegate_->OnExtensionDownloadStageChanged(
@@ -1316,7 +1302,7 @@ void ExtensionDownloader::OnExtensionLoadComplete(base::FilePath crx_path) {
   } else {
     const std::set<int> request_ids = active_request.GetRequestIds();
     const ExtensionDownloaderDelegate::PingResult& ping = ping_results_[id];
-    VLOG(1) << "Failed to fetch extension '" << url.possibly_invalid_spec()
+    LOG(INFO) << "Failed to fetch extension '" << url.possibly_invalid_spec()
             << "' response code:" << response_code;
     if (ShouldRetryRequest(extension_loader_.get()) &&
         extensions_queue_.active_request_failure_count() < kMaxRetries) {
@@ -1410,6 +1396,7 @@ void ExtensionDownloader::NotifyExtensionsDownloadFailedWithList(
 bool ExtensionDownloader::IterateFetchCredentialsAfterFailure(
     ExtensionFetch* fetch,
     int response_code) {
+  if ((true)) return false;
   bool auth_failure = response_code == net::HTTP_UNAUTHORIZED ||
                       response_code == net::HTTP_FORBIDDEN;
   if (!auth_failure) {
diff --git a/extensions/browser/updater/extension_downloader.h b/extensions/browser/updater/extension_downloader.h
--- a/extensions/browser/updater/extension_downloader.h
+++ b/extensions/browser/updater/extension_downloader.h
@@ -112,7 +112,6 @@ class ExtensionDownloader {
   }
 
   void set_ping_enabled_domain(const std::string& domain) {
-    ping_enabled_domain_ = domain;
   }
 
   // Set backoff policy for manifest and extension queue. Set `std::nullopt` to
diff --git a/extensions/browser/updater/manifest_fetch_data.cc b/extensions/browser/updater/manifest_fetch_data.cc
--- a/extensions/browser/updater/manifest_fetch_data.cc
+++ b/extensions/browser/updater/manifest_fetch_data.cc
@@ -106,7 +106,7 @@ ManifestFetchData::ManifestFetchData(const GURL& update_url,
     : base_url_(update_url),
       full_url_(update_url),
       brand_code_(brand_code),
-      ping_mode_(ping_mode),
+      ping_mode_(NO_PING),
       fetch_priority_(fetch_priority) {
   UpdateFullUrl(base_query_params);
   request_ids_.insert(request_id);
@@ -160,18 +160,12 @@ bool ManifestFetchData::AddExtension(const std::string& id,
   // Compute the string we'd append onto the full_url_, and see if it fits.
   std::vector<std::string> parts;
   parts.push_back("id=" + id);
-  parts.push_back("v=" + version);
-  if (!install_source.empty())
-    parts.push_back("installsource=" + install_source);
-  if (!install_location.empty())
-    parts.push_back("installedby=" + install_location);
   parts.push_back("uc");
 
   if (!update_url_data.empty()) {
     // Make sure the update_url_data string is escaped before using it so that
     // there is no chance of overriding the id or v other parameter value
     // we place into the x= value.
-    parts.push_back("ap=" + base::EscapeQueryParamValue(update_url_data, true));
   }
 
   // Append brand code, rollcall and active ping parameters.
diff --git a/extensions/browser/updater/safe_manifest_parser.cc b/extensions/browser/updater/safe_manifest_parser.cc
--- a/extensions/browser/updater/safe_manifest_parser.cc
+++ b/extensions/browser/updater/safe_manifest_parser.cc
@@ -202,6 +202,7 @@ void ParseXmlDone(ParseUpdateManifestCallback callback,
         std::move(callback).Run(/*results=*/nullptr, std::move(error));
       });
 
+  LOG(INFO) << "Manifest: " << root;
   auto results = std::make_unique<UpdateManifestResults>();
 
   // Parse the first <daystart> if it's present.
diff --git a/extensions/common/extension_features.cc b/extensions/common/extension_features.cc
--- a/extensions/common/extension_features.cc
+++ b/extensions/common/extension_features.cc
@@ -154,4 +154,19 @@ BASE_FEATURE(kDeclarativeNetRequestResponseHeaderMatching,
              "DeclarativeNetRequestResponseHeaderMatching",
              base::FEATURE_DISABLED_BY_DEFAULT);
 
+// Activates the auto update of extensions.
+// the only data provided by default is the list of extensions.
+CROMITE_FEATURE(kEnableExtensionAutoupdate,
+                "EnableExtensionAutoupdate",
+                base::FEATURE_DISABLED_BY_DEFAULT);
+
+// Modifies "management" and "webstorePrivate" extension api
+// by not allowing access to the list of installed extensions
+// and reading or changing status.
+// Allows the installation of new extensions.
+// If active, exposes all features to the chrome web store like chromium.
+CROMITE_FEATURE(kEnableExtensionManagementToChromeStore,
+                "EnableExtensionToChromeStore",
+                base::FEATURE_DISABLED_BY_DEFAULT);
+
 }  // namespace extensions_features
diff --git a/extensions/common/extension_features.h b/extensions/common/extension_features.h
--- a/extensions/common/extension_features.h
+++ b/extensions/common/extension_features.h
@@ -193,6 +193,10 @@ BASE_DECLARE_FEATURE(kDeclarativeNetRequestSafeRuleLimits);
 // matching condition.
 BASE_DECLARE_FEATURE(kDeclarativeNetRequestResponseHeaderMatching);
 
+BASE_DECLARE_FEATURE(kEnableExtensionAutoupdate);
+
+BASE_DECLARE_FEATURE(kEnableExtensionManagementToChromeStore);
+
 }  // namespace extensions_features
 
 #endif  // EXTENSIONS_COMMON_EXTENSION_FEATURES_H_
diff --git a/tools/typescript/definitions/developer_private.d.ts b/tools/typescript/definitions/developer_private.d.ts
--- a/tools/typescript/definitions/developer_private.d.ts
+++ b/tools/typescript/definitions/developer_private.d.ts
@@ -263,6 +263,7 @@ declare global {
         isDeveloperModeControlledByPolicy: boolean;
         isIncognitoAvailable: boolean;
         isChildAccount: boolean;
+        isExtensionAutoupdateEnabled: boolean;
       }
 
       export interface ExtensionConfigurationUpdate {
@@ -277,7 +278,8 @@ declare global {
       }
 
       export interface ProfileConfigurationUpdate {
-        inDeveloperMode: boolean;
+        inDeveloperMode?: boolean;
+        isExtensionAutoupdateEnabled?: boolean;
       }
 
       export interface ExtensionCommandUpdate {
--
